import { getLogger, tryAsync, failure, ValidationError, success, AccountError, TransactionError, TimeoutError, NetworkError } from './chunk-UUBQRI4N.mjs';
import { PublicKey, SystemProgram, TransactionInstruction, TransactionMessage, VersionedTransaction } from '@solana/web3.js';
import { Buffer as Buffer$1 } from 'buffer';
import { getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, createInitializeAccountInstruction, createCloseAccountInstruction, ASSOCIATED_TOKEN_PROGRAM_ID as ASSOCIATED_TOKEN_PROGRAM_ID$1, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID$1 } from '@solana/spl-token';
import { AnchorProvider, Program } from '@coral-xyz/anchor';
import { BN } from 'bn.js';

/* LetsBonkSDK - Modern TypeScript Web3 SDK */
var LETSBONK_PROGRAM_ID = new PublicKey("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj");
var RAYDIUM_AUTHORITY = new PublicKey("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh");
var GLOBAL_CONFIG = new PublicKey("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");
var PLATFORM_CONFIG = new PublicKey("FfYek5vEz23cMkWsdJwG2oa6EphsvXSHrGpdALN4g6W1");
var EVENT_AUTHORITY = new PublicKey("2DPAtwB8L12vrMRExbLuyGnC7n2J5LNoZQSejeQGpwkr");
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(
  "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
);
var SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
var METAPLEX_PROGRAM = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
var RENT_SYSVAR = new PublicKey("SysvarRent111111111111111111111111111111111");
var WSOL_TOKEN = new PublicKey("So11111111111111111111111111111111111111112");
var PLATFORM_ADMIN = new PublicKey("2P56vRWDrCBGkqYXxgSWAnuZQZrJPySRQGToTJThpmkN");

// src/constants/defaults.ts
var DEFAULT_COMMITMENT = "confirmed";
var DEFAULT_FINALITY = "confirmed";
var DEFAULT_SLIPPAGE_BASIS_POINTS = 500n;
var DEFAULT_SHARE_FEE_RATE = 0;
var DEFAULT_MAX_RETRIES = 3;
var DEFAULT_TIMEOUT_MS = 6e4;
var ALT_ACCOUNT_ADDRESS = "AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";
var TOKEN_DECIMAL = 6;
var SOL_DECIMAL = 9;
var UNIT_PRICE = 25e5;
var UNIT_BUDGET = 4e5;
var DEFAULT_SUPPLY = "1000000000000000";
var DEFAULT_BASE_SELL = "793100000000000";
var DEFAULT_QUOTE_RAISING = "85000000000";
var SDK_VERSION = "2.0.0";
var SDK_NAME = "LetsBonkSDK";
var GLOBAL_CONFIG_SIZE = 64;
var PLATFORM_CONFIG_SIZE = 64;
var POOL_STATE_SIZE = 256;
var VAULT_AUTH_SEED = Buffer$1.from("vault_auth_seed");
var EVENT_AUTHORITY_SEED = Buffer$1.from("__event_authority");
var GLOBAL_CONFIG_SEED = Buffer$1.from("global_config");
var PLATFORM_CONFIG_SEED = Buffer$1.from("platform_config");
var POOL_SEED = Buffer$1.from("pool");
var POOL_VAULT_SEED = Buffer$1.from("pool_vault");
var POOL_VESTING_SEED = Buffer$1.from("pool_vesting");
var METADATA_SEED = Buffer$1.from("metadata");
var PDA_SEEDS = {
  GLOBAL_CONFIG: "global_config",
  PLATFORM_CONFIG: "platform_config",
  POOL_STATE: "pool_state",
  BASE_VAULT: "base_vault",
  QUOTE_VAULT: "quote_vault",
  VAULT_AUTHORITY: "vault_authority",
  EVENT_AUTHORITY: "event_authority"
};
var INITIALIZE_DISCRIMINATOR = "afaf6d1f0d989bed";
var BUY_EXACT_IN_DISCRIMINATOR = "faea0d7bd59c13ec";
var SELL_EXACT_IN_DISCRIMINATOR = "9527de9bd37c981a";

// src/shared/base-manager.ts
var BaseManager = class {
  program;
  connection;
  logger;
  constructor(program, connection, logger4) {
    this.program = program;
    this.connection = connection;
    this.logger = logger4;
  }
  /**
   * Execute an operation with standardized error handling, logging, and timing
   */
  async executeOperation(operationName, operation, errorMapper, context) {
    const timer = this.logger.startTimer(operationName);
    try {
      this.logger.debug(`Starting ${operationName}`, context);
      const result = await tryAsync(operation(), errorMapper);
      if (result.success) {
        this.logger.info(`${operationName} completed successfully`, context);
        timer.end({ success: true });
      } else {
        this.logger.error(`${operationName} failed`, {
          ...context,
          error: result.error.message
        });
        timer.end({ success: false, error: result.error.message });
      }
      return result;
    } catch (error) {
      const mappedError = errorMapper(error);
      this.logger.logError(mappedError, context);
      timer.end({ success: false, error: mappedError.message });
      return { success: false, error: mappedError };
    }
  }
  /**
   * Execute a synchronous operation with standardized error handling
   */
  executeSync(operationName, operation, errorMapper, context) {
    try {
      this.logger.debug(`Starting ${operationName}`, context);
      const result = operation();
      this.logger.debug(`${operationName} completed successfully`, context);
      return { success: true, data: result };
    } catch (error) {
      const mappedError = errorMapper(error);
      this.logger.logError(mappedError, context);
      return { success: false, error: mappedError };
    }
  }
};
var PDAUtils = class _PDAUtils {
  static DEFAULT_PROGRAM_ID = LETSBONK_PROGRAM_ID;
  static DEFAULT_QUOTE_MINT = WSOL_TOKEN;
  static DEFAULT_METAPLEX_PROGRAM = METAPLEX_PROGRAM;
  static DEFAULT_PLATFORM_ADMIN = PLATFORM_ADMIN;
  /**
   * Find the vault authority PDA
   */
  static findVaultAuthority(programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync([VAULT_AUTH_SEED], programId);
  }
  /**
   * Find the pool state PDA for given base and quote mints
   */
  static findPoolState(baseMint, quoteMint = _PDAUtils.DEFAULT_QUOTE_MINT, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync(
      [POOL_SEED, baseMint.toBuffer(), quoteMint.toBuffer()],
      programId
    );
  }
  /**
   * Find the base vault PDA for a pool
   */
  static findBaseVault(poolState, baseMint, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync(
      [POOL_VAULT_SEED, poolState.toBuffer(), baseMint.toBuffer()],
      programId
    );
  }
  /**
   * Find the quote vault PDA for a pool
   */
  static findQuoteVault(poolState, quoteMint, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync(
      [POOL_VAULT_SEED, poolState.toBuffer(), quoteMint.toBuffer()],
      programId
    );
  }
  /**
   * Find the vesting record PDA for a pool and beneficiary
   */
  static findVestingRecord(poolState, beneficiary, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync(
      [POOL_VESTING_SEED, poolState.toBuffer(), beneficiary.toBuffer()],
      programId
    );
  }
  /**
   * Find the metadata PDA for a token
   */
  static findMetadata(mint, programId = _PDAUtils.DEFAULT_METAPLEX_PROGRAM) {
    return PublicKey.findProgramAddressSync(
      [METADATA_SEED, programId.toBuffer(), mint.toBuffer()],
      programId
    );
  }
  /**
   * Find the event authority PDA
   */
  static findEventAuthority(programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync([EVENT_AUTHORITY_SEED], programId);
  }
  /**
   * Find the global config PDA
   */
  static findGlobalConfig(quoteMint = _PDAUtils.DEFAULT_QUOTE_MINT, curveType = 0, index = 0, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    const curveTypeBuffer = Buffer.alloc(1);
    curveTypeBuffer.writeUInt8(curveType, 0);
    const indexBuffer = Buffer.alloc(2);
    indexBuffer.writeUInt16LE(index, 0);
    return PublicKey.findProgramAddressSync(
      [GLOBAL_CONFIG_SEED, quoteMint.toBuffer(), curveTypeBuffer, indexBuffer],
      programId
    );
  }
  /**
   * Find the platform config PDA
   */
  static findPlatformConfig(platformAdmin = _PDAUtils.DEFAULT_PLATFORM_ADMIN, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync(
      [PLATFORM_CONFIG_SEED, platformAdmin.toBuffer()],
      programId
    );
  }
  /**
   * Derive all PDAs for a given mint in one call
   */
  static deriveAll(mint, quoteMint = _PDAUtils.DEFAULT_QUOTE_MINT, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    const [poolState] = _PDAUtils.findPoolState(mint, quoteMint, programId);
    const [baseVault] = _PDAUtils.findBaseVault(poolState, mint, programId);
    const [quoteVault] = _PDAUtils.findQuoteVault(poolState, quoteMint, programId);
    const [metadata] = _PDAUtils.findMetadata(mint);
    const [authority] = _PDAUtils.findVaultAuthority(programId);
    return {
      poolState,
      baseVault,
      quoteVault,
      metadata,
      authority
    };
  }
  /**
   * Get all required PDAs for trading operations
   */
  static forTrading(baseMint, quoteMint = _PDAUtils.DEFAULT_QUOTE_MINT, programId = _PDAUtils.DEFAULT_PROGRAM_ID) {
    const core = _PDAUtils.deriveAll(baseMint, quoteMint, programId);
    const [globalConfig] = _PDAUtils.findGlobalConfig(quoteMint, 0, 0, programId);
    const [platformConfig] = _PDAUtils.findPlatformConfig(
      _PDAUtils.DEFAULT_PLATFORM_ADMIN,
      programId
    );
    const [eventAuthority] = _PDAUtils.findEventAuthority(programId);
    return {
      ...core,
      globalConfig,
      platformConfig,
      eventAuthority
    };
  }
};

// src/shared/validators.ts
var SharedValidators = class _SharedValidators {
  /**
   * Validate PublicKey
   */
  static validatePublicKey(key, fieldName) {
    if (!key) {
      return failure(new ValidationError(`${fieldName} is required`, fieldName, key));
    }
    try {
      key.toString();
      return success(void 0);
    } catch {
      return failure(new ValidationError(`Invalid ${fieldName}`, fieldName, key));
    }
  }
  /**
   * Validate Keypair
   */
  static validateKeypair(keypair, fieldName) {
    if (!keypair) {
      return failure(new ValidationError(`${fieldName} keypair is required`, fieldName, keypair));
    }
    if (!keypair.publicKey || !keypair.secretKey) {
      return failure(new ValidationError(`Invalid ${fieldName} keypair`, fieldName, keypair));
    }
    return success(void 0);
  }
  /**
   * Validate string field
   */
  static validateString(value, fieldName, minLength = 1, maxLength = 1e3) {
    if (!value || typeof value !== "string") {
      return failure(new ValidationError(`${fieldName} is required`, fieldName, value));
    }
    const trimmed = value.trim();
    if (trimmed.length < minLength) {
      return failure(
        new ValidationError(
          `${fieldName} must be at least ${minLength} characters`,
          fieldName,
          value
        )
      );
    }
    if (trimmed.length > maxLength) {
      return failure(
        new ValidationError(
          `${fieldName} must be at most ${maxLength} characters`,
          fieldName,
          value
        )
      );
    }
    return success(void 0);
  }
  /**
   * Validate bigint amount
   */
  static validateBigIntAmount(amount, fieldName, minAmount = 0n) {
    if (amount === void 0 || amount === null) {
      return failure(new ValidationError(`${fieldName} is required`, fieldName, amount));
    }
    if (typeof amount !== "bigint") {
      return failure(new ValidationError(`${fieldName} must be a bigint`, fieldName, amount));
    }
    if (amount < minAmount) {
      return failure(
        new ValidationError(`${fieldName} must be at least ${minAmount}`, fieldName, amount)
      );
    }
    return success(void 0);
  }
  /**
   * Validate URL
   */
  static validateURL(url, fieldName, required = false) {
    if (!url) {
      if (required) {
        return failure(new ValidationError(`${fieldName} is required`, fieldName, url));
      }
      return success(void 0);
    }
    try {
      new URL(url);
      return success(void 0);
    } catch {
      return failure(new ValidationError(`Invalid ${fieldName} URL`, fieldName, url));
    }
  }
  /**
   * Validate file blob
   */
  static validateFile(file, fieldName, maxSizeBytes = 10 * 1024 * 1024) {
    if (!file) {
      return failure(new ValidationError(`${fieldName} is required`, fieldName, file));
    }
    if (!(file instanceof Blob)) {
      return failure(new ValidationError(`${fieldName} must be a Blob`, fieldName, file));
    }
    if (file.size === 0) {
      return failure(new ValidationError(`${fieldName} cannot be empty`, fieldName, file));
    }
    if (file.size > maxSizeBytes) {
      return failure(
        new ValidationError(
          `${fieldName} size cannot exceed ${maxSizeBytes / (1024 * 1024)}MB`,
          fieldName,
          file.size
        )
      );
    }
    return success(void 0);
  }
  /**
   * Validate token metadata
   */
  static validateTokenMetadata(metadata) {
    const nameValidation = _SharedValidators.validateString(metadata.name, "name", 1, 32);
    if (!nameValidation.success) return nameValidation;
    const symbolValidation = _SharedValidators.validateString(metadata.symbol, "symbol", 1, 10);
    if (!symbolValidation.success) return symbolValidation;
    const descValidation = _SharedValidators.validateString(
      metadata.description,
      "description",
      1,
      1e3
    );
    if (!descValidation.success) return descValidation;
    const fileValidation = _SharedValidators.validateFile(metadata.file, "file");
    if (!fileValidation.success) return fileValidation;
    const websiteValidation = _SharedValidators.validateURL(metadata.website, "website");
    if (!websiteValidation.success) return websiteValidation;
    return success(void 0);
  }
  /**
   * Validate buy parameters
   */
  static validateBuyParams(params) {
    const buyerValidation = _SharedValidators.validateKeypair(params.buyer, "buyer");
    if (!buyerValidation.success) return buyerValidation;
    const baseMintValidation = _SharedValidators.validatePublicKey(params.baseMint, "baseMint");
    if (!baseMintValidation.success) return baseMintValidation;
    const amountInValidation = _SharedValidators.validateBigIntAmount(
      params.amountIn,
      "amountIn",
      1n
    );
    if (!amountInValidation.success) return amountInValidation;
    const minAmountValidation = _SharedValidators.validateBigIntAmount(
      params.minimumAmountOut,
      "minimumAmountOut",
      0n
    );
    if (!minAmountValidation.success) return minAmountValidation;
    return success(void 0);
  }
  /**
   * Validate sell parameters
   */
  static validateSellParams(params) {
    const sellerValidation = _SharedValidators.validateKeypair(params.seller, "seller");
    if (!sellerValidation.success) return sellerValidation;
    const baseMintValidation = _SharedValidators.validatePublicKey(params.baseMint, "baseMint");
    if (!baseMintValidation.success) return baseMintValidation;
    const amountInValidation = _SharedValidators.validateBigIntAmount(
      params.amountIn,
      "amountIn",
      1n
    );
    if (!amountInValidation.success) return amountInValidation;
    const minAmountValidation = _SharedValidators.validateBigIntAmount(
      params.minimumAmountOut,
      "minimumAmountOut",
      0n
    );
    if (!minAmountValidation.success) return minAmountValidation;
    return success(void 0);
  }
  /**
   * Validate initialize parameters
   */
  static validateInitializeParams(params) {
    const payerValidation = _SharedValidators.validateKeypair(params.payer, "payer");
    if (!payerValidation.success) return payerValidation;
    const creatorValidation = _SharedValidators.validatePublicKey(params.creator, "creator");
    if (!creatorValidation.success) return creatorValidation;
    const baseMintValidation = _SharedValidators.validateKeypair(params.baseMint, "baseMint");
    if (!baseMintValidation.success) return baseMintValidation;
    if (!params.tokenMetadata) {
      return failure(
        new ValidationError("Token metadata is required", "tokenMetadata", params.tokenMetadata)
      );
    }
    const metadataValidation = _SharedValidators.validateTokenMetadata(params.tokenMetadata);
    if (!metadataValidation.success) return metadataValidation;
    return success(void 0);
  }
};
function isValidPublicKey(key) {
  return !key.equals(SystemProgram.programId);
}

// src/managers/account-manager.ts
var AccountManager = class {
  constructor(program, connection, logger4) {
    this.program = program;
    this.connection = connection;
    this.logger = logger4.child({ manager: "AccountManager" });
  }
  logger;
  /**
   * Get global configuration account
   */
  async getGlobalConfig(quoteMint = WSOL_TOKEN, curveType = 0, index = 0) {
    const timer = this.logger.startTimer("getGlobalConfig");
    try {
      this.logger.debug("Fetching global config", {
        quoteMint: quoteMint.toString(),
        curveType,
        index
      });
      const [globalConfigPDA] = PDAUtils.findGlobalConfig(quoteMint, curveType, index);
      const result = await tryAsync(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.program.account.globalConfig.fetch(globalConfigPDA),
        (error) => new AccountError(
          `Failed to fetch global config: ${error.message}`,
          globalConfigPDA.toString(),
          "GlobalConfig",
          error
        )
      );
      if (!result.success) {
        this.logger.error("Failed to fetch global config", {
          address: globalConfigPDA.toString(),
          error: result.error.message
        });
        return failure(result.error);
      }
      const globalConfig = result.data;
      this.logger.info("Global config fetched successfully", {
        address: globalConfigPDA.toString(),
        tradeFeeRate: globalConfig.tradeFeeRate?.toString(),
        protocolFeeRate: globalConfig.protocolFeeRate?.toString()
      });
      timer.end({ success: true });
      return success(globalConfig);
    } catch (error) {
      const accountError = new AccountError(
        `Unexpected error fetching global config: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        "GlobalConfig",
        error instanceof Error ? error : void 0
      );
      this.logger.logError(accountError);
      timer.end({ success: false, error: accountError.message });
      return failure(accountError);
    }
  }
  /**
   * Get platform configuration account
   */
  async getPlatformConfig(platformAdmin, index = 0) {
    const timer = this.logger.startTimer("getPlatformConfig");
    try {
      this.logger.debug("Fetching platform config", {
        platformAdmin: platformAdmin?.toString(),
        index
      });
      const [platformConfigPDA] = PDAUtils.findPlatformConfig(platformAdmin);
      const result = await tryAsync(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.program.account.platformConfig.fetch(platformConfigPDA),
        (error) => new AccountError(
          `Failed to fetch platform config: ${error.message}`,
          platformConfigPDA.toString(),
          "PlatformConfig",
          error
        )
      );
      if (!result.success) {
        this.logger.error("Failed to fetch platform config", {
          address: platformConfigPDA.toString(),
          error: result.error.message
        });
        return failure(result.error);
      }
      const platformConfig = result.data;
      this.logger.info("Platform config fetched successfully", {
        address: platformConfigPDA.toString(),
        name: platformConfig.name,
        feeRate: platformConfig.feeRate?.toString()
      });
      timer.end({ success: true });
      return success(platformConfig);
    } catch (error) {
      const accountError = new AccountError(
        `Unexpected error fetching platform config: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        "PlatformConfig",
        error instanceof Error ? error : void 0
      );
      this.logger.logError(accountError);
      timer.end({ success: false, error: accountError.message });
      return failure(accountError);
    }
  }
  /**
   * Get pool state account
   */
  async getPoolState(baseMint, quoteMint = WSOL_TOKEN) {
    const timer = this.logger.startTimer("getPoolState");
    try {
      if (!isValidPublicKey(baseMint)) {
        const validationError = new ValidationError(
          "Invalid base mint provided",
          "baseMint",
          baseMint
        );
        this.logger.error("Invalid base mint", { baseMint: baseMint.toString() });
        return failure(validationError);
      }
      this.logger.debug("Fetching pool state", {
        baseMint: baseMint.toString(),
        quoteMint: quoteMint.toString()
      });
      const [poolStatePDA] = PDAUtils.findPoolState(baseMint, quoteMint);
      const result = await tryAsync(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.program.account.poolState.fetch(poolStatePDA),
        (error) => new AccountError(
          `Failed to fetch pool state: ${error.message}`,
          poolStatePDA.toString(),
          "PoolState",
          error
        )
      );
      if (!result.success) {
        if (result.error.message.includes("Account does not exist")) {
          this.logger.debug("Pool state not found (not initialized)", {
            poolAddress: poolStatePDA.toString()
          });
          timer.end({ success: true, found: false });
          return success(null);
        }
        this.logger.error("Failed to fetch pool state", {
          poolAddress: poolStatePDA.toString(),
          error: result.error.message
        });
        return failure(result.error);
      }
      const poolState = result.data;
      this.logger.info("Pool state fetched successfully", {
        poolAddress: poolStatePDA.toString(),
        baseMint: poolState.baseMint.toString(),
        quoteMint: poolState.quoteMint.toString(),
        realBase: poolState.realBase?.toString(),
        realQuote: poolState.realQuote?.toString()
      });
      timer.end({ success: true, found: true });
      return success(poolState);
    } catch (error) {
      const accountError = new AccountError(
        `Unexpected error fetching pool state: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        "PoolState",
        error instanceof Error ? error : void 0
      );
      this.logger.logError(accountError);
      timer.end({ success: false, error: accountError.message });
      return failure(accountError);
    }
  }
  /**
   * Check if pool exists
   */
  async poolExists(baseMint, quoteMint = WSOL_TOKEN) {
    const result = await this.getPoolState(baseMint, quoteMint);
    if (!result.success) {
      return result;
    }
    return success(result.data !== null);
  }
  /**
   * Get multiple account states in parallel
   */
  async getMultipleAccountStates(requests) {
    const timer = this.logger.startTimer("getMultipleAccountStates");
    try {
      this.logger.debug("Fetching multiple account states", {
        accountCount: requests.length
      });
      const promises = requests.map(async ({ address, type }) => {
        try {
          let account;
          switch (type) {
            case "GlobalConfig":
              account = await this.program.account.globalConfig.fetch(address);
              break;
            case "PlatformConfig":
              account = await this.program.account.platformConfig.fetch(address);
              break;
            case "PoolState":
              account = await this.program.account.poolState.fetch(address);
              break;
            default:
              throw new Error(`Unknown account type: ${type}`);
          }
          return { address, type, data: account, success: true };
        } catch (error) {
          return {
            address,
            type,
            error: error instanceof Error ? error.message : "Unknown error",
            success: false
          };
        }
      });
      const results = await Promise.all(promises);
      const successCount = results.filter((r) => r.success).length;
      this.logger.info("Multiple account states fetched", {
        total: requests.length,
        successful: successCount,
        failed: requests.length - successCount
      });
      timer.end({ success: true });
      return success(results);
    } catch (error) {
      const accountError = new AccountError(
        `Unexpected error fetching multiple account states: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        "MultipleAccounts",
        error instanceof Error ? error : void 0
      );
      this.logger.logError(accountError);
      timer.end({ success: false, error: accountError.message });
      return failure(accountError);
    }
  }
};

// src/utils/formatting.ts
function bufferFromString(stringData) {
  const strBytes = Buffer.from(stringData, "utf-8");
  const length = strBytes.length;
  const lengthBuffer = Buffer.alloc(4);
  lengthBuffer.writeUInt32LE(length, 0);
  return Buffer.concat([lengthBuffer, strBytes]);
}
function basisPointsToPercentage(basisPoints) {
  return Number(basisPoints) / 100;
}
function percentageToBasisPoints(percentage) {
  return BigInt(Math.floor(percentage * 100));
}

// src/instructions/launch.ts
function buildLaunchInstruction(params) {
  const {
    mintKeypair,
    payerKeypair,
    poolStatePDA,
    baseVaultPDA,
    quoteVaultPDA,
    metadataPDA,
    name,
    symbol,
    uri,
    decimals = 6,
    supply = DEFAULT_SUPPLY,
    baseSell = DEFAULT_BASE_SELL,
    quoteRaising = DEFAULT_QUOTE_RAISING
  } = params;
  const mintParams = Buffer.concat([
    Buffer.from([decimals]),
    // decimals (u8)
    bufferFromString(name),
    // name (string)
    bufferFromString(symbol),
    // symbol (string)
    bufferFromString(uri)
    // uri (string)
  ]);
  const curveParams = Buffer.concat([
    Buffer.from([0]),
    // variant discriminator for Constant (0)
    Buffer.from(new BigUint64Array([BigInt(supply)]).buffer),
    // supply (u64)
    Buffer.from(new BigUint64Array([BigInt(baseSell)]).buffer),
    // total base sell (u64)
    Buffer.from(new BigUint64Array([BigInt(quoteRaising)]).buffer),
    // total quote fund raising (u64)
    Buffer.from([1])
    // migrate type (u8)
  ]);
  const vestingParams = Buffer.concat([
    Buffer.from(new BigUint64Array([BigInt(0)]).buffer),
    // total locked amount (u64)
    Buffer.from(new BigUint64Array([BigInt(0)]).buffer),
    // cliff period (u64)
    Buffer.from(new BigUint64Array([BigInt(0)]).buffer)
    // unlock period (u64)
  ]);
  const instructionDiscriminator = Buffer.from(INITIALIZE_DISCRIMINATOR, "hex");
  const data = Buffer.concat([instructionDiscriminator, mintParams, curveParams, vestingParams]);
  const [globalConfigPDA] = PDAUtils.findGlobalConfig();
  const [platformConfigPDA] = PDAUtils.findPlatformConfig();
  const [vaultAuthorityPDA] = PDAUtils.findVaultAuthority();
  const [eventAuthorityPDA] = PDAUtils.findEventAuthority();
  const keys = [
    // Payer
    {
      pubkey: payerKeypair.publicKey,
      isSigner: true,
      isWritable: true
    },
    // Creator
    {
      pubkey: payerKeypair.publicKey,
      isSigner: true,
      isWritable: true
    },
    // Global Config
    {
      pubkey: globalConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Platform Config
    {
      pubkey: platformConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Authority
    {
      pubkey: vaultAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Pool state
    {
      pubkey: poolStatePDA,
      isSigner: false,
      isWritable: true
    },
    // Base mint (new token mint)
    {
      pubkey: mintKeypair.publicKey,
      isSigner: true,
      isWritable: true
    },
    // Quote token (WSOL)
    {
      pubkey: WSOL_TOKEN,
      isSigner: false,
      isWritable: false
    },
    // Base vault
    {
      pubkey: baseVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Quote vault
    {
      pubkey: quoteVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Metadata account
    {
      pubkey: metadataPDA,
      isSigner: false,
      isWritable: true
    },
    // Base token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Quote token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Metadata program
    {
      pubkey: METAPLEX_PROGRAM,
      isSigner: false,
      isWritable: false
    },
    // System program
    {
      pubkey: SYSTEM_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Rent sysvar
    {
      pubkey: RENT_SYSVAR,
      isSigner: false,
      isWritable: false
    },
    // Event authority
    {
      pubkey: eventAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Raydium program
    {
      pubkey: LETSBONK_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    }
  ];
  return new TransactionInstruction({
    keys,
    programId: LETSBONK_PROGRAM_ID,
    data
  });
}
function buildBuyInstruction(params) {
  const {
    payerPubkey,
    poolStatePDA,
    baseVaultPDA,
    quoteVaultPDA,
    baseMint,
    baseTokenAccount,
    wsolTokenAccount,
    amountIn,
    minimumAmountOut,
    shareFeeRate = 0n
  } = params;
  const instructionDiscriminator = Buffer.from(BUY_EXACT_IN_DISCRIMINATOR, "hex");
  const data = Buffer.concat([
    instructionDiscriminator,
    // Amount in (u64) - use raw lamports directly (no conversion needed!)
    Buffer.from(new BigUint64Array([amountIn]).buffer),
    // Minimum amount out (u64) - use raw token amount directly (no conversion needed!)
    Buffer.from(new BigUint64Array([minimumAmountOut]).buffer),
    // Share fee rate (u64)
    Buffer.from(new BigUint64Array([shareFeeRate]).buffer)
  ]);
  const [globalConfigPDA] = PDAUtils.findGlobalConfig();
  const [platformConfigPDA] = PDAUtils.findPlatformConfig();
  const [vaultAuthorityPDA] = PDAUtils.findVaultAuthority();
  const [eventAuthorityPDA] = PDAUtils.findEventAuthority();
  const keys = [
    // Payer
    {
      pubkey: payerPubkey,
      isSigner: true,
      isWritable: true
    },
    // Authority
    {
      pubkey: vaultAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Global config
    {
      pubkey: globalConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Platform config
    {
      pubkey: platformConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Pool state
    {
      pubkey: poolStatePDA,
      isSigner: false,
      isWritable: true
    },
    // Base token account (user)
    {
      pubkey: baseTokenAccount,
      isSigner: false,
      isWritable: true
    },
    // WSOL token account (user)
    {
      pubkey: wsolTokenAccount,
      isSigner: false,
      isWritable: true
    },
    // Base vault
    {
      pubkey: baseVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Quote vault
    {
      pubkey: quoteVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Base mint
    {
      pubkey: baseMint,
      isSigner: false,
      isWritable: true
    },
    // Quote mint (WSOL)
    {
      pubkey: WSOL_TOKEN,
      isSigner: false,
      isWritable: false
    },
    // Base token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Quote token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Event authority
    {
      pubkey: eventAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Raydium program
    {
      pubkey: LETSBONK_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    }
  ];
  return new TransactionInstruction({
    keys,
    programId: LETSBONK_PROGRAM_ID,
    data
  });
}
function buildSellInstruction(params) {
  const {
    payerPubkey,
    poolStatePDA,
    baseVaultPDA,
    quoteVaultPDA,
    baseMint,
    baseTokenAccount,
    wsolTokenAccount,
    amountIn,
    minimumAmountOut,
    shareFeeRate = 0n
  } = params;
  const instructionDiscriminator = Buffer.from(SELL_EXACT_IN_DISCRIMINATOR, "hex");
  const data = Buffer.concat([
    instructionDiscriminator,
    // Amount in (u64) - use raw token amount directly (no conversion needed!)
    Buffer.from(new BigUint64Array([amountIn]).buffer),
    // Minimum amount out (u64) - use raw lamports directly (no conversion needed!)
    Buffer.from(new BigUint64Array([minimumAmountOut]).buffer),
    // Share fee rate (u64)
    Buffer.from(new BigUint64Array([shareFeeRate]).buffer)
  ]);
  const [globalConfigPDA] = PDAUtils.findGlobalConfig();
  const [platformConfigPDA] = PDAUtils.findPlatformConfig();
  const [vaultAuthorityPDA] = PDAUtils.findVaultAuthority();
  const [eventAuthorityPDA] = PDAUtils.findEventAuthority();
  const keys = [
    // Payer
    {
      pubkey: payerPubkey,
      isSigner: true,
      isWritable: true
    },
    // Authority
    {
      pubkey: vaultAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Global config
    {
      pubkey: globalConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Platform config
    {
      pubkey: platformConfigPDA,
      isSigner: false,
      isWritable: false
    },
    // Pool state
    {
      pubkey: poolStatePDA,
      isSigner: false,
      isWritable: true
    },
    // Base token account (user)
    {
      pubkey: baseTokenAccount,
      isSigner: false,
      isWritable: true
    },
    // WSOL token account (user)
    {
      pubkey: wsolTokenAccount,
      isSigner: false,
      isWritable: true
    },
    // Base vault
    {
      pubkey: baseVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Quote vault
    {
      pubkey: quoteVaultPDA,
      isSigner: false,
      isWritable: true
    },
    // Base mint
    {
      pubkey: baseMint,
      isSigner: false,
      isWritable: true
    },
    // Quote mint (WSOL)
    {
      pubkey: WSOL_TOKEN,
      isSigner: false,
      isWritable: false
    },
    // Base token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Quote token program
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    // Event authority
    {
      pubkey: eventAuthorityPDA,
      isSigner: false,
      isWritable: false
    },
    // Raydium program
    {
      pubkey: LETSBONK_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    }
  ];
  return new TransactionInstruction({
    keys,
    programId: LETSBONK_PROGRAM_ID,
    data
  });
}
function getAltAccountPublicKey() {
  return new PublicKey(ALT_ACCOUNT_ADDRESS);
}
async function fetchAltAccount(connection) {
  try {
    const altAddress = getAltAccountPublicKey();
    const result = await connection.getAddressLookupTable(altAddress);
    return result.value;
  } catch {
    return null;
  }
}
async function setupV0Transaction(connection, payer, instructions, priorityFees) {
  const { blockhash } = await connection.getLatestBlockhash();
  const unitPrice = priorityFees?.unitPrice ?? UNIT_PRICE;
  const unitBudget = priorityFees?.unitLimit ?? UNIT_BUDGET;
  const computeBudgetInstructions = [
    // Set compute unit price
    new TransactionInstruction({
      keys: [],
      programId: new PublicKey("ComputeBudget111111111111111111111111111111"),
      data: Buffer.concat([
        Buffer.from([3]),
        // SetComputeUnitPrice instruction
        Buffer.from(new Uint8Array(new BigUint64Array([BigInt(unitPrice)]).buffer))
      ])
    }),
    // Set compute unit limit
    new TransactionInstruction({
      keys: [],
      programId: new PublicKey("ComputeBudget111111111111111111111111111111"),
      data: Buffer.concat([
        Buffer.from([2]),
        // SetComputeUnitLimit instruction
        Buffer.from(new Uint8Array(new Uint32Array([unitBudget]).buffer))
      ])
    })
  ];
  const allInstructions = [...computeBudgetInstructions, ...instructions];
  const altAccount = await fetchAltAccount(connection);
  const messageV0 = new TransactionMessage({
    payerKey: payer,
    recentBlockhash: blockhash,
    instructions: allInstructions
  }).compileToV0Message(altAccount ? [altAccount] : []);
  const transaction = new VersionedTransaction(messageV0);
  return transaction;
}
async function createOrGetTokenAccount(connection, owner, mint) {
  try {
    const tokenAccount = await getAssociatedTokenAddress(mint, owner);
    const accountInfo = await connection.getAccountInfo(tokenAccount);
    if (accountInfo) {
      return { address: tokenAccount };
    }
    const instruction = createAssociatedTokenAccountInstruction(
      owner,
      // payer
      tokenAccount,
      // associatedToken
      owner,
      // owner
      mint
      // mint
    );
    return { address: tokenAccount, instruction };
  } catch (error) {
    throw new Error(`Failed to create or get token account: ${error}`);
  }
}
async function createTemporaryWSOLAccount(connection, payer, amount) {
  const seed = Math.random().toString(36).substring(2, 15);
  const wsolAccount = await PublicKey.createWithSeed(payer, seed, TOKEN_PROGRAM_ID);
  const lamports = Math.floor(amount * Math.pow(10, SOL_DECIMAL));
  const rentExemptBalance = await connection.getMinimumBalanceForRentExemption(165);
  const totalLamports = lamports + rentExemptBalance;
  const instructions = [
    // Create account with seed - no additional signers needed
    SystemProgram.createAccountWithSeed({
      fromPubkey: payer,
      basePubkey: payer,
      seed,
      newAccountPubkey: wsolAccount,
      lamports: totalLamports,
      space: 165,
      programId: TOKEN_PROGRAM_ID
    }),
    // Initialize as WSOL token account
    createInitializeAccountInstruction(wsolAccount, WSOL_TOKEN, payer)
  ];
  return { address: wsolAccount, instructions, keypair: void 0 };
}
function getCloseWSOLInstruction(wsolAccount, owner) {
  return createCloseAccountInstruction(wsolAccount, owner, owner);
}

// src/utils/calculation.ts
function calculateTokensReceive(solAmount, previousSol = 30, slippage = 5) {
  const k = 1073e6 * previousSol;
  const newSol = previousSol + solAmount;
  const newTokens = k / newSol;
  const tokenAmount = 1073e6 - newTokens;
  const slippageFactor = (100 - slippage) / 100;
  const adjustedTokenAmount = tokenAmount * slippageFactor;
  const priceImpact = solAmount / previousSol * 100;
  return {
    tokenAmount: adjustedTokenAmount,
    priceImpact
  };
}
function calculateSlippageBuy(amount, slippageBasisPoints) {
  return amount - amount * slippageBasisPoints / 10000n;
}
function calculateSlippageSell(amount, slippageBasisPoints) {
  return amount - amount * slippageBasisPoints / 10000n;
}
function calculateMinimumAmountOut(expectedAmount, slippageBasisPoints) {
  const minimumAmountOut = calculateSlippageSell(expectedAmount, slippageBasisPoints);
  const priceImpact = Number(slippageBasisPoints) / 100;
  const effectivePrice = Number(expectedAmount) / Number(minimumAmountOut);
  return {
    minimumAmountOut,
    priceImpact,
    effectivePrice
  };
}

// src/utils/metadata.ts
var logger = getLogger();
async function uploadTokenMetadata(metadata, retries = 5, delay = 1e3) {
  const formData = new FormData();
  formData.append("file", metadata.file);
  formData.append("name", metadata.name);
  formData.append("symbol", metadata.symbol);
  formData.append("description", metadata.description);
  formData.append("twitter", metadata.twitter || "");
  formData.append("telegram", metadata.telegram || "");
  formData.append("website", metadata.website || "");
  formData.append("showName", "true");
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const request = await fetch("https://pump.fun/api/ipfs", {
        method: "POST",
        body: formData
      });
      if (!request.ok) {
        throw new Error(`HTTP error! status: ${request.status}`);
      }
      const result = await request.json();
      return {
        metadataUri: result.metadataUri,
        success: true
      };
    } catch (error) {
      if (attempt < retries - 1) {
        logger.warn(`IPFS upload attempt ${attempt + 1} failed. Retrying...`, {
          attempt: attempt + 1,
          retries,
          tokenName: metadata.name,
          error
        });
        await new Promise((resolve) => setTimeout(resolve, delay));
      } else {
        logger.error("All IPFS upload attempts failed", {
          attempts: retries,
          tokenName: metadata.name,
          error
        });
        return {
          metadataUri: "",
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    }
  }
  return {
    metadataUri: "",
    success: false,
    error: "Upload failed after all retries"
  };
}
function createImageBlob(imageData, mimeType = "image/jpeg") {
  const base64Data = imageData.replace(/^data:image\/[a-z]+;base64,/, "");
  const byteCharacters = atob(base64Data);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}
async function createImageBlobFromUrl(imageUrl) {
  try {
    const response = await fetch(imageUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.status}`);
    }
    return await response.blob();
  } catch (error) {
    throw new Error(
      `Failed to create blob from URL: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function prepareTokenMetadata(params) {
  const { name, symbol, description, imageInput, twitter, telegram, website } = params;
  let file;
  if (imageInput instanceof Blob) {
    file = imageInput;
  } else if (typeof imageInput === "string") {
    if (imageInput.startsWith("data:") || !imageInput.startsWith("http") && imageInput.length > 100) {
      file = createImageBlob(imageInput);
    } else {
      file = await createImageBlobFromUrl(imageInput);
    }
  } else {
    throw new Error("Invalid image input type. Must be Blob, base64 string, or URL.");
  }
  return {
    name,
    symbol,
    description,
    file,
    twitter,
    telegram,
    website
  };
}

// src/IDL/letsbonk.json
var letsbonk_default = {
  address: "LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj",
  metadata: {
    name: "raydium_launchpad",
    version: "0.1.0",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "buy_exact_in",
      docs: [
        "Use the given amount of quote tokens to purchase base tokens.",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `amount_in` - Amount of quote token to purchase",
        "* `minimum_amount_out` - Minimum amount of base token to receive (slippage protection)",
        "* `share_fee_rate` - Fee rate for the share",
        ""
      ],
      discriminator: [
        250,
        234,
        13,
        123,
        213,
        156,
        19,
        236
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "The user performing the swap operation",
            "Must sign the transaction and pay for fees"
          ],
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account containing protocol-wide settings",
            "Used to read protocol fee rates and curve type"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform-wide settings",
            "Used to read platform fee rate"
          ]
        },
        {
          name: "pool_state",
          docs: [
            "The pool state account where the swap will be performed",
            "Contains current pool parameters and balances"
          ],
          writable: true
        },
        {
          name: "user_base_token",
          docs: [
            "The user's token account for base tokens (tokens being bought)",
            "Will receive the output tokens after the swap"
          ],
          writable: true
        },
        {
          name: "user_quote_token",
          docs: [
            "The user's token account for quote tokens (tokens being sold)",
            "Will be debited for the input amount"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be debited to send tokens to the user"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will receive the input tokens from the user"
          ],
          writable: true
        },
        {
          name: "base_token_mint",
          docs: [
            "The mint of the base token",
            "Used for transfer fee calculations if applicable"
          ]
        },
        {
          name: "quote_token_mint",
          docs: [
            "The mint of the quote token"
          ]
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for base token transfers"
          ]
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for quote token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "minimum_amount_out",
          type: "u64"
        },
        {
          name: "share_fee_rate",
          type: "u64"
        }
      ]
    },
    {
      name: "buy_exact_out",
      docs: [
        "Use quote tokens to purchase the given amount of base tokens.",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `amount_out` - Amount of base token to receive",
        "* `maximum_amount_in` - Maximum amount of quote token to purchase (slippage protection)",
        "* `share_fee_rate` - Fee rate for the share"
      ],
      discriminator: [
        24,
        211,
        116,
        40,
        105,
        3,
        153,
        56
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "The user performing the swap operation",
            "Must sign the transaction and pay for fees"
          ],
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account containing protocol-wide settings",
            "Used to read protocol fee rates and curve type"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform-wide settings",
            "Used to read platform fee rate"
          ]
        },
        {
          name: "pool_state",
          docs: [
            "The pool state account where the swap will be performed",
            "Contains current pool parameters and balances"
          ],
          writable: true
        },
        {
          name: "user_base_token",
          docs: [
            "The user's token account for base tokens (tokens being bought)",
            "Will receive the output tokens after the swap"
          ],
          writable: true
        },
        {
          name: "user_quote_token",
          docs: [
            "The user's token account for quote tokens (tokens being sold)",
            "Will be debited for the input amount"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be debited to send tokens to the user"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will receive the input tokens from the user"
          ],
          writable: true
        },
        {
          name: "base_token_mint",
          docs: [
            "The mint of the base token",
            "Used for transfer fee calculations if applicable"
          ]
        },
        {
          name: "quote_token_mint",
          docs: [
            "The mint of the quote token"
          ]
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for base token transfers"
          ]
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for quote token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_out",
          type: "u64"
        },
        {
          name: "maximum_amount_in",
          type: "u64"
        },
        {
          name: "share_fee_rate",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_platform_fee",
      docs: [
        "Claim platform fee",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        ""
      ],
      discriminator: [
        156,
        39,
        208,
        135,
        76,
        237,
        61,
        72
      ],
      accounts: [
        {
          name: "platform_fee_wallet",
          docs: [
            "Only the wallet stored in platform_config can collect platform fees"
          ],
          writable: true,
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault and mint operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Account that stores the pool's state and parameters",
            "PDA generated using POOL_SEED and both token mints"
          ],
          writable: true
        },
        {
          name: "platform_config",
          docs: [
            "The platform config account"
          ]
        },
        {
          name: "quote_vault",
          writable: true
        },
        {
          name: "recipient_token_account",
          docs: [
            "The address that receives the collected quote token fees"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "platform_fee_wallet"
              },
              {
                kind: "const",
                value: [
                  6,
                  221,
                  246,
                  225,
                  215,
                  101,
                  161,
                  147,
                  217,
                  203,
                  225,
                  70,
                  206,
                  235,
                  121,
                  172,
                  28,
                  180,
                  133,
                  237,
                  95,
                  91,
                  55,
                  145,
                  58,
                  140,
                  245,
                  133,
                  126,
                  255,
                  0,
                  169
                ]
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token vault"
          ]
        },
        {
          name: "token_program",
          docs: [
            "SPL program for input token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "associated_token_program",
          docs: [
            "Required for associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        }
      ],
      args: []
    },
    {
      name: "claim_vested_token",
      docs: [
        "Claim vested token",
        "# Arguments"
      ],
      discriminator: [
        49,
        33,
        104,
        30,
        189,
        157,
        79,
        35
      ],
      accounts: [
        {
          name: "beneficiary",
          docs: [
            "The beneficiary of the vesting account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault and mint operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Account that stores the pool's state and parameters",
            "PDA generated using POOL_SEED and both token mints"
          ],
          writable: true
        },
        {
          name: "vesting_record",
          docs: [
            "The vesting record account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  101,
                  115,
                  116,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "pool_state"
              },
              {
                kind: "account",
                path: "beneficiary"
              }
            ]
          }
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be debited to send tokens to the user"
          ],
          writable: true
        },
        {
          name: "user_base_token",
          writable: true,
          signer: true
        },
        {
          name: "base_token_mint",
          docs: [
            "The mint for the base token (token being sold)",
            "Created in this instruction with specified decimals"
          ]
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for the base token",
            "Must be the standard Token program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "associated_token_program",
          docs: [
            "Required for associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        }
      ],
      args: []
    },
    {
      name: "collect_fee",
      docs: [
        "Collects accumulated fees from the pool",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        ""
      ],
      discriminator: [
        60,
        173,
        247,
        103,
        4,
        93,
        130,
        48
      ],
      accounts: [
        {
          name: "owner",
          docs: [
            "Only protocol_fee_owner saved in global_config can collect protocol fee now"
          ],
          signer: true
        },
        {
          name: "authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Pool state stores accumulated protocol fee amount"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global config account stores owner"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The address that holds pool tokens for quote token"
          ],
          writable: true
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token vault"
          ]
        },
        {
          name: "recipient_token_account",
          docs: [
            "The address that receives the collected quote token fees"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "SPL program for input token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      args: []
    },
    {
      name: "collect_migrate_fee",
      docs: [
        "Collects  migrate fees from the pool",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        ""
      ],
      discriminator: [
        255,
        186,
        150,
        223,
        235,
        118,
        201,
        186
      ],
      accounts: [
        {
          name: "owner",
          docs: [
            "Only migrate_fee_owner saved in global_config can collect migrate fee now"
          ],
          signer: true
        },
        {
          name: "authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Pool state stores accumulated protocol fee amount"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global config account stores owner"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The address that holds pool tokens for quote token"
          ],
          writable: true
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token vault"
          ]
        },
        {
          name: "recipient_token_account",
          docs: [
            "The address that receives the collected quote token fees"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "SPL program for input token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      args: []
    },
    {
      name: "create_config",
      docs: [
        "Creates a new configuration",
        "# Arguments",
        "",
        "* `ctx` - The accounts needed by instruction",
        "* `curve_type` - The type of bonding curve (0: ConstantProduct)",
        "* `index` - The index of config, there may be multiple config with the same curve type.",
        "* `trade_fee_rate` - Trade fee rate, must be less than RATE_DENOMINATOR_VALUE",
        ""
      ],
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "owner",
          docs: [
            "The protocol owner/admin account",
            "Must match the predefined admin address",
            "Has authority to create and modify protocol configurations"
          ],
          writable: true,
          signer: true,
          address: "GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ"
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account that stores protocol-wide settings",
            "PDA generated using GLOBAL_CONFIG_SEED, quote token mint, and curve type",
            "Stores fee rates and protocol parameters"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "quote_token_mint"
              },
              {
                kind: "arg",
                path: "curve_type"
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "quote_token_mint",
          docs: [
            "The mint address of the quote token (token used for buying)",
            "This will be the standard token used for all pools with this config"
          ]
        },
        {
          name: "protocol_fee_owner",
          docs: [
            "Account that will receive protocol fees"
          ]
        },
        {
          name: "migrate_fee_owner",
          docs: [
            "Account that will receive migrate fees"
          ]
        },
        {
          name: "migrate_to_amm_wallet",
          docs: [
            "The control wallet address for migrating to amm"
          ]
        },
        {
          name: "migrate_to_cpswap_wallet",
          docs: [
            "The control wallet address for migrating to cpswap"
          ]
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "curve_type",
          type: "u8"
        },
        {
          name: "index",
          type: "u16"
        },
        {
          name: "migrate_fee",
          type: "u64"
        },
        {
          name: "trade_fee_rate",
          type: "u64"
        }
      ]
    },
    {
      name: "create_platform_config",
      docs: [
        "Create platform config account",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "# Fields",
        "* `fee_rate` - Fee rate of the platform",
        "* `name` - Name of the platform",
        "* `web` - Website of the platform",
        "* `img` - Image link of the platform",
        ""
      ],
      discriminator: [
        176,
        90,
        196,
        175,
        253,
        113,
        220,
        20
      ],
      accounts: [
        {
          name: "platform_admin",
          docs: [
            "The account paying for the initialization costs"
          ],
          writable: true,
          signer: true
        },
        {
          name: "platform_fee_wallet"
        },
        {
          name: "platform_nft_wallet"
        },
        {
          name: "platform_config",
          docs: [
            "The platform config account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  108,
                  97,
                  116,
                  102,
                  111,
                  114,
                  109,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "platform_admin"
              }
            ]
          }
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "platform_params",
          type: {
            defined: {
              name: "PlatformParams"
            }
          }
        }
      ]
    },
    {
      name: "create_vesting_account",
      docs: [
        "Create vesting account",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `share` - The share amount of base token to be vested",
        ""
      ],
      discriminator: [
        129,
        178,
        2,
        13,
        217,
        172,
        230,
        218
      ],
      accounts: [
        {
          name: "creator",
          docs: [
            "The account paying for the initialization costs",
            "This can be any account with sufficient SOL to cover the transaction"
          ],
          writable: true,
          signer: true
        },
        {
          name: "beneficiary",
          writable: true
        },
        {
          name: "pool_state",
          docs: [
            "The pool state account"
          ],
          writable: true
        },
        {
          name: "vesting_record",
          docs: [
            "The vesting record account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  101,
                  115,
                  116,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "pool_state"
              },
              {
                kind: "account",
                path: "beneficiary"
              }
            ]
          }
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "share_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "initialize",
      docs: [
        "Initializes a new trading pool",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts containing pool and token information",
        ""
      ],
      discriminator: [
        175,
        175,
        109,
        31,
        13,
        152,
        155,
        237
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "The account paying for the initialization costs",
            "This can be any account with sufficient SOL to cover the transaction"
          ],
          writable: true,
          signer: true
        },
        {
          name: "creator"
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account containing protocol-wide settings",
            "Includes settings like quote token mint and fee parameters"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform info",
            "Includes settings like the fee_rate, name, web, img of the platform"
          ]
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault and mint operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Account that stores the pool's state and parameters",
            "PDA generated using POOL_SEED and both token mints"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108
                ]
              },
              {
                kind: "account",
                path: "base_mint"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ]
          }
        },
        {
          name: "base_mint",
          docs: [
            "The mint for the base token (token being sold)",
            "Created in this instruction with specified decimals"
          ],
          writable: true,
          signer: true
        },
        {
          name: "quote_mint",
          docs: [
            "The mint for the quote token (token used to buy)",
            "Must match the quote_mint specified in global config"
          ]
        },
        {
          name: "base_vault",
          docs: [
            "Token account that holds the pool's base tokens",
            "PDA generated using POOL_VAULT_SEED"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "pool_state"
              },
              {
                kind: "account",
                path: "base_mint"
              }
            ]
          }
        },
        {
          name: "quote_vault",
          docs: [
            "Token account that holds the pool's quote tokens",
            "PDA generated using POOL_VAULT_SEED"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "pool_state"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ]
          }
        },
        {
          name: "metadata_account",
          docs: [
            "Account to store the base token's metadata",
            "Created using Metaplex metadata program"
          ],
          writable: true
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for the base token",
            "Must be the standard Token program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for the quote token"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "metadata_program",
          docs: [
            "Metaplex Token Metadata program",
            "Used to create metadata for the base token"
          ],
          address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent_program",
          docs: [
            "Required for rent exempt calculations"
          ],
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "base_mint_param",
          type: {
            defined: {
              name: "MintParams"
            }
          }
        },
        {
          name: "curve_param",
          type: {
            defined: {
              name: "CurveParams"
            }
          }
        },
        {
          name: "vesting_param",
          type: {
            defined: {
              name: "VestingParams"
            }
          }
        }
      ]
    },
    {
      name: "migrate_to_amm",
      docs: [
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        ""
      ],
      discriminator: [
        207,
        82,
        192,
        145,
        254,
        207,
        145,
        223
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "Only migrate_to_amm_wallet can migrate to cpswap pool",
            "This signer must match the migrate_to_amm_wallet saved in global_config"
          ],
          writable: true,
          signer: true
        },
        {
          name: "base_mint",
          docs: [
            "The mint for the base token (token being sold)"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint for the quote token (token used to buy)"
          ]
        },
        {
          name: "openbook_program",
          address: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"
        },
        {
          name: "market",
          docs: [
            "Account created and asigned to openbook_program but not been initialized"
          ],
          writable: true
        },
        {
          name: "request_queue",
          docs: [
            "Account created and asigned to openbook_program but not been initialized"
          ],
          writable: true
        },
        {
          name: "event_queue",
          docs: [
            "Account created and asigned to openbook_program but not been initialized"
          ],
          writable: true
        },
        {
          name: "bids",
          docs: [
            "Account created and asigned to openbook_program but not been initialized"
          ],
          writable: true
        },
        {
          name: "asks",
          docs: [
            "Account created and asigned to openbook_program but not been initialized"
          ],
          writable: true
        },
        {
          name: "market_vault_signer"
        },
        {
          name: "market_base_vault",
          docs: [
            "Token account that holds the market's base tokens"
          ],
          writable: true
        },
        {
          name: "market_quote_vault",
          docs: [
            "Token account that holds the market's quote tokens"
          ],
          writable: true
        },
        {
          name: "amm_program",
          address: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
        },
        {
          name: "amm_pool",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  97,
                  109,
                  109,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  109,
                  109,
                  32,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_open_orders",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  111,
                  112,
                  101,
                  110,
                  95,
                  111,
                  114,
                  100,
                  101,
                  114,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_lp_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  108,
                  112,
                  95,
                  109,
                  105,
                  110,
                  116,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_base_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  99,
                  111,
                  105,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_quote_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  112,
                  99,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_target_orders",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "amm_program"
              },
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "const",
                value: [
                  116,
                  97,
                  114,
                  103,
                  101,
                  116,
                  95,
                  97,
                  115,
                  115,
                  111,
                  99,
                  105,
                  97,
                  116,
                  101,
                  100,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_config",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  109,
                  109,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "amm_program"
            }
          }
        },
        {
          name: "amm_create_fee_destination",
          writable: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Account that stores the pool's state and parameters",
            "PDA generated using POOL_SEED and both token mints"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108
                ]
              },
              {
                kind: "account",
                path: "base_mint"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global config account stores owner"
          ]
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be fully drained during migration"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will be fully drained during migration"
          ],
          writable: true
        },
        {
          name: "pool_lp_token",
          writable: true
        },
        {
          name: "spl_token_program",
          docs: [
            "SPL Token program for the base token",
            "Must be the standard Token program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "associated_token_program",
          docs: [
            "Program to create an ATA for receiving fee NFT"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent_program",
          docs: [
            "Required for rent exempt calculations"
          ],
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "base_lot_size",
          type: "u64"
        },
        {
          name: "quote_lot_size",
          type: "u64"
        },
        {
          name: "market_vault_signer_nonce",
          type: "u8"
        }
      ]
    },
    {
      name: "migrate_to_cpswap",
      docs: [
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        ""
      ],
      discriminator: [
        136,
        92,
        200,
        103,
        28,
        218,
        144,
        140
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "Only migrate_to_cpswap_wallet can migrate to cpswap pool",
            "This signer must match the migrate_to_cpswap_wallet saved in global_config"
          ],
          writable: true,
          signer: true
        },
        {
          name: "base_mint",
          docs: [
            "The mint for the base token (token being sold)"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint for the quote token (token used to buy)"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform-wide settings",
            "Used to read platform fee rate"
          ]
        },
        {
          name: "cpswap_program",
          address: "CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"
        },
        {
          name: "cpswap_pool",
          docs: [
            "PDA account:",
            "seeds = [",
            'b"pool",',
            "cpswap_config.key().as_ref(),",
            "token_0_mint.key().as_ref(),",
            "token_1_mint.key().as_ref(),",
            "],",
            "seeds::program = cpswap_program,",
            "",
            "Or random account: must be signed by cli"
          ],
          writable: true
        },
        {
          name: "cpswap_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  110,
                  100,
                  95,
                  108,
                  112,
                  95,
                  109,
                  105,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "cpswap_program"
            }
          }
        },
        {
          name: "cpswap_lp_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  108,
                  112,
                  95,
                  109,
                  105,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "cpswap_pool"
              }
            ],
            program: {
              kind: "account",
              path: "cpswap_program"
            }
          }
        },
        {
          name: "cpswap_base_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "cpswap_pool"
              },
              {
                kind: "account",
                path: "base_mint"
              }
            ],
            program: {
              kind: "account",
              path: "cpswap_program"
            }
          }
        },
        {
          name: "cpswap_quote_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "cpswap_pool"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ],
            program: {
              kind: "account",
              path: "cpswap_program"
            }
          }
        },
        {
          name: "cpswap_config"
        },
        {
          name: "cpswap_create_pool_fee",
          writable: true
        },
        {
          name: "cpswap_observation",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  111,
                  98,
                  115,
                  101,
                  114,
                  118,
                  97,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "cpswap_pool"
              }
            ],
            program: {
              kind: "account",
              path: "cpswap_program"
            }
          }
        },
        {
          name: "lock_program",
          address: "LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"
        },
        {
          name: "lock_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  108,
                  111,
                  99,
                  107,
                  95,
                  99,
                  112,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ],
            program: {
              kind: "account",
              path: "lock_program"
            }
          }
        },
        {
          name: "lock_lp_vault",
          writable: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "pool_state",
          docs: [
            "Account that stores the pool's state and parameters",
            "PDA generated using POOL_SEED and both token mints"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108
                ]
              },
              {
                kind: "account",
                path: "base_mint"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global config account stores owner"
          ]
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be fully drained during migration"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will be fully drained during migration"
          ],
          writable: true
        },
        {
          name: "pool_lp_token",
          writable: true
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for the base token",
            "Must be the standard Token program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for the quote token"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "associated_token_program",
          docs: [
            "Program to create an ATA for receiving fee NFT"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "Required for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent_program",
          docs: [
            "Required for rent exempt calculations"
          ],
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "metadata_program",
          docs: [
            "Program to create NFT metadata accunt"
          ],
          address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
        }
      ],
      args: []
    },
    {
      name: "sell_exact_in",
      docs: [
        "Use the given amount of base tokens to sell for quote tokens.",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `amount_in` - Amount of base token to sell",
        "* `minimum_amount_out` - Minimum amount of quote token to receive (slippage protection)",
        "* `share_fee_rate` - Fee rate for the share",
        ""
      ],
      discriminator: [
        149,
        39,
        222,
        155,
        211,
        124,
        152,
        26
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "The user performing the swap operation",
            "Must sign the transaction and pay for fees"
          ],
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account containing protocol-wide settings",
            "Used to read protocol fee rates and curve type"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform-wide settings",
            "Used to read platform fee rate"
          ]
        },
        {
          name: "pool_state",
          docs: [
            "The pool state account where the swap will be performed",
            "Contains current pool parameters and balances"
          ],
          writable: true
        },
        {
          name: "user_base_token",
          docs: [
            "The user's token account for base tokens (tokens being bought)",
            "Will receive the output tokens after the swap"
          ],
          writable: true
        },
        {
          name: "user_quote_token",
          docs: [
            "The user's token account for quote tokens (tokens being sold)",
            "Will be debited for the input amount"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be debited to send tokens to the user"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will receive the input tokens from the user"
          ],
          writable: true
        },
        {
          name: "base_token_mint",
          docs: [
            "The mint of the base token",
            "Used for transfer fee calculations if applicable"
          ]
        },
        {
          name: "quote_token_mint",
          docs: [
            "The mint of the quote token"
          ]
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for base token transfers"
          ]
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for quote token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "minimum_amount_out",
          type: "u64"
        },
        {
          name: "share_fee_rate",
          type: "u64"
        }
      ]
    },
    {
      name: "sell_exact_out",
      docs: [
        "Sell base tokens for the given amount of quote tokens.",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `amount_out` - Amount of quote token to receive",
        "* `maximum_amount_in` - Maximum amount of base token to purchase (slippage protection)",
        "* `share_fee_rate` - Fee rate for the share",
        ""
      ],
      discriminator: [
        95,
        200,
        71,
        34,
        8,
        9,
        11,
        166
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "The user performing the swap operation",
            "Must sign the transaction and pay for fees"
          ],
          signer: true
        },
        {
          name: "authority",
          docs: [
            "PDA that acts as the authority for pool vault operations",
            "Generated using AUTH_SEED"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  97,
                  117,
                  108,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  95,
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account containing protocol-wide settings",
            "Used to read protocol fee rates and curve type"
          ]
        },
        {
          name: "platform_config",
          docs: [
            "Platform configuration account containing platform-wide settings",
            "Used to read platform fee rate"
          ]
        },
        {
          name: "pool_state",
          docs: [
            "The pool state account where the swap will be performed",
            "Contains current pool parameters and balances"
          ],
          writable: true
        },
        {
          name: "user_base_token",
          docs: [
            "The user's token account for base tokens (tokens being bought)",
            "Will receive the output tokens after the swap"
          ],
          writable: true
        },
        {
          name: "user_quote_token",
          docs: [
            "The user's token account for quote tokens (tokens being sold)",
            "Will be debited for the input amount"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The pool's vault for base tokens",
            "Will be debited to send tokens to the user"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The pool's vault for quote tokens",
            "Will receive the input tokens from the user"
          ],
          writable: true
        },
        {
          name: "base_token_mint",
          docs: [
            "The mint of the base token",
            "Used for transfer fee calculations if applicable"
          ]
        },
        {
          name: "quote_token_mint",
          docs: [
            "The mint of the quote token"
          ]
        },
        {
          name: "base_token_program",
          docs: [
            "SPL Token program for base token transfers"
          ]
        },
        {
          name: "quote_token_program",
          docs: [
            "SPL Token program for quote token transfers"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_out",
          type: "u64"
        },
        {
          name: "maximum_amount_in",
          type: "u64"
        },
        {
          name: "share_fee_rate",
          type: "u64"
        }
      ]
    },
    {
      name: "update_config",
      docs: [
        "Updates configuration parameters",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `param` - Parameter to update:",
        "- 0: Update trade_fee_rate",
        "- 1: Update fee owner",
        "* `value` - New value for the selected parameter",
        ""
      ],
      discriminator: [
        29,
        158,
        252,
        191,
        10,
        83,
        219,
        99
      ],
      accounts: [
        {
          name: "owner",
          docs: [
            "The global config owner or admin"
          ],
          signer: true,
          address: "GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ"
        },
        {
          name: "global_config",
          docs: [
            "Global config account to be changed"
          ],
          writable: true
        }
      ],
      args: [
        {
          name: "param",
          type: "u8"
        },
        {
          name: "value",
          type: "u64"
        }
      ]
    },
    {
      name: "update_platform_config",
      docs: [
        "Update platform config",
        "# Arguments",
        "",
        "* `ctx` - The context of accounts",
        "* `param` - Parameter to update",
        ""
      ],
      discriminator: [
        195,
        60,
        76,
        129,
        146,
        45,
        67,
        143
      ],
      accounts: [
        {
          name: "platform_admin",
          docs: [
            "The account paying for the initialization costs"
          ],
          signer: true
        },
        {
          name: "platform_config",
          docs: [
            "Platform config account to be changed"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  108,
                  97,
                  116,
                  102,
                  111,
                  114,
                  109,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "platform_admin"
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "param",
          type: {
            defined: {
              name: "PlatformConfigParam"
            }
          }
        }
      ]
    }
  ],
  accounts: [
    {
      name: "GlobalConfig",
      discriminator: [
        149,
        8,
        156,
        202,
        160,
        252,
        176,
        217
      ]
    },
    {
      name: "PlatformConfig",
      discriminator: [
        160,
        78,
        128,
        0,
        248,
        83,
        230,
        160
      ]
    },
    {
      name: "PoolState",
      discriminator: [
        247,
        237,
        227,
        245,
        215,
        195,
        222,
        70
      ]
    },
    {
      name: "VestingRecord",
      discriminator: [
        106,
        243,
        221,
        205,
        230,
        126,
        85,
        83
      ]
    }
  ],
  events: [
    {
      name: "ClaimVestedEvent",
      discriminator: [
        21,
        194,
        114,
        87,
        120,
        211,
        226,
        32
      ]
    },
    {
      name: "CreateVestingEvent",
      discriminator: [
        150,
        152,
        11,
        179,
        52,
        210,
        191,
        125
      ]
    },
    {
      name: "PoolCreateEvent",
      discriminator: [
        151,
        215,
        226,
        9,
        118,
        161,
        115,
        174
      ]
    },
    {
      name: "TradeEvent",
      discriminator: [
        189,
        219,
        127,
        211,
        78,
        230,
        97,
        238
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "NotApproved",
      msg: "Not approved"
    },
    {
      code: 6001,
      name: "InvalidOwner",
      msg: "Input account owner is not the program address"
    },
    {
      code: 6002,
      name: "InvalidInput",
      msg: "InvalidInput"
    },
    {
      code: 6003,
      name: "InputNotMatchCurveConfig",
      msg: "The input params are not match with curve type in config"
    },
    {
      code: 6004,
      name: "ExceededSlippage",
      msg: "Exceeds desired slippage limit"
    },
    {
      code: 6005,
      name: "PoolFunding",
      msg: "Pool funding"
    },
    {
      code: 6006,
      name: "PoolMigrated",
      msg: "Pool migrated"
    },
    {
      code: 6007,
      name: "MigrateTypeNotMatch",
      msg: "Migrate type not match"
    },
    {
      code: 6008,
      name: "MathOverflow",
      msg: "Math overflow"
    },
    {
      code: 6009,
      name: "NoAssetsToCollect",
      msg: "No assets to collect"
    },
    {
      code: 6010,
      name: "VestingRatioTooHigh",
      msg: "Vesting ratio too high"
    },
    {
      code: 6011,
      name: "VestingSettingEnded",
      msg: "Vesting setting ended"
    },
    {
      code: 6012,
      name: "VestingNotStarted",
      msg: "Vesting not started"
    },
    {
      code: 6013,
      name: "NoVestingSchedule",
      msg: "No vesting schedule"
    },
    {
      code: 6014,
      name: "InvalidPlatformInfo",
      msg: "The platform info input is invalid"
    },
    {
      code: 6015,
      name: "PoolNotMigrated",
      msg: "Pool not migrated"
    }
  ],
  types: [
    {
      name: "ClaimVestedEvent",
      docs: [
        "Emitted when vesting token claimed by beneficiary"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_state",
            type: "pubkey"
          },
          {
            name: "beneficiary",
            type: "pubkey"
          },
          {
            name: "claim_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ConstantCurve",
      type: {
        kind: "struct",
        fields: [
          {
            name: "supply",
            type: "u64"
          },
          {
            name: "total_base_sell",
            type: "u64"
          },
          {
            name: "total_quote_fund_raising",
            type: "u64"
          },
          {
            name: "migrate_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "CreateVestingEvent",
      docs: [
        "Emitted when vest_account created"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_state",
            type: "pubkey"
          },
          {
            name: "beneficiary",
            type: "pubkey"
          },
          {
            name: "share_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CurveParams",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Constant",
            fields: [
              {
                name: "data",
                type: {
                  defined: {
                    name: "ConstantCurve"
                  }
                }
              }
            ]
          },
          {
            name: "Fixed",
            fields: [
              {
                name: "data",
                type: {
                  defined: {
                    name: "FixedCurve"
                  }
                }
              }
            ]
          },
          {
            name: "Linear",
            fields: [
              {
                name: "data",
                type: {
                  defined: {
                    name: "LinearCurve"
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      name: "FixedCurve",
      type: {
        kind: "struct",
        fields: [
          {
            name: "supply",
            type: "u64"
          },
          {
            name: "total_quote_fund_raising",
            type: "u64"
          },
          {
            name: "migrate_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "GlobalConfig",
      docs: [
        "Holds the current owner of the factory"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "epoch",
            docs: [
              "Account update epoch"
            ],
            type: "u64"
          },
          {
            name: "curve_type",
            docs: [
              "0: Constant Product Curve",
              "1: Fixed Price Curve",
              "2: Linear Price Curve"
            ],
            type: "u8"
          },
          {
            name: "index",
            docs: [
              "Config index"
            ],
            type: "u16"
          },
          {
            name: "migrate_fee",
            docs: [
              "The fee of migrate to amm"
            ],
            type: "u64"
          },
          {
            name: "trade_fee_rate",
            docs: [
              "The trade fee rate, denominated in hundredths of a bip (10^-6)"
            ],
            type: "u64"
          },
          {
            name: "max_share_fee_rate",
            docs: [
              "The maximum share fee rate, denominated in hundredths of a bip (10^-6)"
            ],
            type: "u64"
          },
          {
            name: "min_base_supply",
            docs: [
              "The minimum base supply, the value without decimals"
            ],
            type: "u64"
          },
          {
            name: "max_lock_rate",
            docs: [
              "The maximum lock rate, denominated in hundredths of a bip (10^-6)"
            ],
            type: "u64"
          },
          {
            name: "min_base_sell_rate",
            docs: [
              "The minimum base sell rate, denominated in hundredths of a bip (10^-6)"
            ],
            type: "u64"
          },
          {
            name: "min_base_migrate_rate",
            docs: [
              "The minimum base migrate rate, denominated in hundredths of a bip (10^-6)"
            ],
            type: "u64"
          },
          {
            name: "min_quote_fund_raising",
            docs: [
              "The minimum quote fund raising, the value with decimals"
            ],
            type: "u64"
          },
          {
            name: "quote_mint",
            docs: [
              "Mint information for quote token"
            ],
            type: "pubkey"
          },
          {
            name: "protocol_fee_owner",
            docs: [
              "Protocol Fee owner"
            ],
            type: "pubkey"
          },
          {
            name: "migrate_fee_owner",
            docs: [
              "Migrate Fee owner"
            ],
            type: "pubkey"
          },
          {
            name: "migrate_to_amm_wallet",
            docs: [
              "Migrate to amm control wallet"
            ],
            type: "pubkey"
          },
          {
            name: "migrate_to_cpswap_wallet",
            docs: [
              "Migrate to cpswap wallet"
            ],
            type: "pubkey"
          },
          {
            name: "padding",
            docs: [
              "padding for future updates"
            ],
            type: {
              array: [
                "u64",
                16
              ]
            }
          }
        ]
      }
    },
    {
      name: "LinearCurve",
      type: {
        kind: "struct",
        fields: [
          {
            name: "supply",
            type: "u64"
          },
          {
            name: "total_quote_fund_raising",
            type: "u64"
          },
          {
            name: "migrate_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "MigrateNftInfo",
      docs: [
        "Represents the parameters for initializing a platform config account(Only support MigrateType::CPSWAP)",
        "# Fields",
        "* `platform_scale` - Scale of the platform liquidity quantity rights will be converted into NFT",
        "* `creator_scale` - Scale of the token creator liquidity quantity rights will be converted into NFT",
        "* `burn_scale` - Scale of liquidity directly to burn",
        "",
        "* platform_scale + creator_scale + burn_scale = RATE_DENOMINATOR_VALUE"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "platform_scale",
            type: "u64"
          },
          {
            name: "creator_scale",
            type: "u64"
          },
          {
            name: "burn_scale",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "MintParams",
      docs: [
        "Represents the parameters for initializing a new token mint",
        "# Fields",
        "* `decimals` - Number of decimal places for the token",
        "* `name` - Name of the token",
        "* `symbol` - Symbol/ticker of the token",
        "* `uri` - URI pointing to token metadata"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "decimals",
            type: "u8"
          },
          {
            name: "name",
            type: "string"
          },
          {
            name: "symbol",
            type: "string"
          },
          {
            name: "uri",
            type: "string"
          }
        ]
      }
    },
    {
      name: "PlatformConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "epoch",
            docs: [
              "The epoch for update interval"
            ],
            type: "u64"
          },
          {
            name: "platform_fee_wallet",
            docs: [
              "The platform fee wallet"
            ],
            type: "pubkey"
          },
          {
            name: "platform_nft_wallet",
            docs: [
              "The platform nft wallet to receive the platform NFT after migration if platform_scale is not 0(Only support MigrateType::CPSWAP)"
            ],
            type: "pubkey"
          },
          {
            name: "platform_scale",
            docs: [
              "Scale of the platform liquidity quantity rights will be converted into NFT(Only support MigrateType::CPSWAP)"
            ],
            type: "u64"
          },
          {
            name: "creator_scale",
            docs: [
              "Scale of the token creator liquidity quantity rights will be converted into NFT(Only support MigrateType::CPSWAP)"
            ],
            type: "u64"
          },
          {
            name: "burn_scale",
            docs: [
              "Scale of liquidity directly to burn"
            ],
            type: "u64"
          },
          {
            name: "fee_rate",
            docs: [
              "The platform fee rate"
            ],
            type: "u64"
          },
          {
            name: "name",
            docs: [
              "The platform name"
            ],
            type: {
              array: [
                "u8",
                64
              ]
            }
          },
          {
            name: "web",
            docs: [
              "The platform website"
            ],
            type: {
              array: [
                "u8",
                256
              ]
            }
          },
          {
            name: "img",
            docs: [
              "The platform img link"
            ],
            type: {
              array: [
                "u8",
                256
              ]
            }
          },
          {
            name: "padding",
            docs: [
              "padding for future updates"
            ],
            type: {
              array: [
                "u8",
                256
              ]
            }
          }
        ]
      }
    },
    {
      name: "PlatformConfigParam",
      type: {
        kind: "enum",
        variants: [
          {
            name: "FeeWallet",
            fields: [
              "pubkey"
            ]
          },
          {
            name: "NFTWallet",
            fields: [
              "pubkey"
            ]
          },
          {
            name: "MigrateNftInfo",
            fields: [
              {
                defined: {
                  name: "MigrateNftInfo"
                }
              }
            ]
          },
          {
            name: "FeeRate",
            fields: [
              "u64"
            ]
          },
          {
            name: "Name",
            fields: [
              "string"
            ]
          },
          {
            name: "Web",
            fields: [
              "string"
            ]
          },
          {
            name: "Img",
            fields: [
              "string"
            ]
          }
        ]
      }
    },
    {
      name: "PlatformParams",
      docs: [
        "Represents the parameters for initializing a platform config account",
        "# Fields",
        "* `migrate_nft_info` - The platform configures liquidity info during migration(Only support MigrateType::CPSWAP)",
        "* `fee_rate` - Fee rate of the platform",
        "* `name` - Name of the platform",
        "* `web` - Website of the platform",
        "* `img` - Image link of the platform"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "migrate_nft_info",
            type: {
              defined: {
                name: "MigrateNftInfo"
              }
            }
          },
          {
            name: "fee_rate",
            type: "u64"
          },
          {
            name: "name",
            type: "string"
          },
          {
            name: "web",
            type: "string"
          },
          {
            name: "img",
            type: "string"
          }
        ]
      }
    },
    {
      name: "PoolCreateEvent",
      docs: [
        "Emitted when pool created"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_state",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "base_mint_param",
            type: {
              defined: {
                name: "MintParams"
              }
            }
          },
          {
            name: "curve_param",
            type: {
              defined: {
                name: "CurveParams"
              }
            }
          },
          {
            name: "vesting_param",
            type: {
              defined: {
                name: "VestingParams"
              }
            }
          }
        ]
      }
    },
    {
      name: "PoolState",
      docs: [
        "Represents the state of a trading pool in the protocol",
        "Stores all essential information about pool balances, fees, and configuration"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "epoch",
            docs: [
              "Account update epoch"
            ],
            type: "u64"
          },
          {
            name: "auth_bump",
            docs: [
              "Bump seed used for PDA address derivation"
            ],
            type: "u8"
          },
          {
            name: "status",
            docs: [
              "Current status of the pool",
              "* 0: Pool is funding",
              "* 1: Pool funding is end, waiting for migration",
              "* 2: Pool migration is done"
            ],
            type: "u8"
          },
          {
            name: "base_decimals",
            docs: [
              "Decimals of the pool base token"
            ],
            type: "u8"
          },
          {
            name: "quote_decimals",
            docs: [
              "Decimals of the pool quote token"
            ],
            type: "u8"
          },
          {
            name: "migrate_type",
            docs: [
              "Migrate to AMM or CpSwap"
            ],
            type: "u8"
          },
          {
            name: "supply",
            docs: [
              "Supply of the pool base token"
            ],
            type: "u64"
          },
          {
            name: "total_base_sell",
            docs: [
              "Total sell amount of the base token"
            ],
            type: "u64"
          },
          {
            name: "virtual_base",
            docs: [
              "For different curves, virtual_base and virtual_quote have different meanings",
              "For constant product curve, virtual_base and virtual_quote are virtual liquidity, virtual_quote/virtual_base is the initial price",
              "For linear price curve, virtual_base is the price slope parameter a, virtual_quote has no effect",
              "For fixed price curve, virtual_quote/virtual_base is the initial price"
            ],
            type: "u64"
          },
          {
            name: "virtual_quote",
            type: "u64"
          },
          {
            name: "real_base",
            docs: [
              "Actual base token amount in the pool",
              "Represents the real tokens available for trading"
            ],
            type: "u64"
          },
          {
            name: "real_quote",
            docs: [
              "Actual quote token amount in the pool",
              "Represents the real tokens available for trading"
            ],
            type: "u64"
          },
          {
            name: "total_quote_fund_raising",
            docs: [
              "The total quote fund raising of the pool"
            ],
            type: "u64"
          },
          {
            name: "quote_protocol_fee",
            docs: [
              "Accumulated trading fees in quote tokens",
              "Can be collected by the protocol fee owner"
            ],
            type: "u64"
          },
          {
            name: "platform_fee",
            docs: [
              "Accumulated platform fees in quote tokens",
              "Can be collected by the platform wallet stored in platform config"
            ],
            type: "u64"
          },
          {
            name: "migrate_fee",
            docs: [
              "The fee of migrate to amm"
            ],
            type: "u64"
          },
          {
            name: "vesting_schedule",
            docs: [
              "Vesting schedule for the base token"
            ],
            type: {
              defined: {
                name: "VestingSchedule"
              }
            }
          },
          {
            name: "global_config",
            docs: [
              "Public key of the global configuration account",
              "Contains protocol-wide settings this pool adheres to"
            ],
            type: "pubkey"
          },
          {
            name: "platform_config",
            docs: [
              "Public key of the platform configuration account",
              "Contains platform-wide settings this pool adheres to"
            ],
            type: "pubkey"
          },
          {
            name: "base_mint",
            docs: [
              "Public key of the base mint address"
            ],
            type: "pubkey"
          },
          {
            name: "quote_mint",
            docs: [
              "Public key of the quote mint address"
            ],
            type: "pubkey"
          },
          {
            name: "base_vault",
            docs: [
              "Public key of the base token vault",
              "Holds the actual base tokens owned by the pool"
            ],
            type: "pubkey"
          },
          {
            name: "quote_vault",
            docs: [
              "Public key of the quote token vault",
              "Holds the actual quote tokens owned by the pool"
            ],
            type: "pubkey"
          },
          {
            name: "creator",
            docs: [
              "The creator of base token"
            ],
            type: "pubkey"
          },
          {
            name: "padding",
            docs: [
              "padding for future updates"
            ],
            type: {
              array: [
                "u64",
                8
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolStatus",
      docs: [
        "Represents the different states a pool can be in",
        "* Fund - Initial state where pool is accepting funds",
        "* Migrate - Pool funding has ended and waiting for migration",
        "* Trade - Pool migration is complete and amm trading is enabled"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Fund"
          },
          {
            name: "Migrate"
          },
          {
            name: "Trade"
          }
        ]
      }
    },
    {
      name: "TradeDirection",
      docs: [
        "Specifies the direction of a trade in the bonding curve",
        "This is important because curves can treat tokens differently through weights or offsets"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Buy"
          },
          {
            name: "Sell"
          }
        ]
      }
    },
    {
      name: "TradeEvent",
      docs: [
        "Emitted when trade process"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_state",
            type: "pubkey"
          },
          {
            name: "total_base_sell",
            type: "u64"
          },
          {
            name: "virtual_base",
            type: "u64"
          },
          {
            name: "virtual_quote",
            type: "u64"
          },
          {
            name: "real_base_before",
            type: "u64"
          },
          {
            name: "real_quote_before",
            type: "u64"
          },
          {
            name: "real_base_after",
            type: "u64"
          },
          {
            name: "real_quote_after",
            type: "u64"
          },
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "amount_out",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "platform_fee",
            type: "u64"
          },
          {
            name: "share_fee",
            type: "u64"
          },
          {
            name: "trade_direction",
            type: {
              defined: {
                name: "TradeDirection"
              }
            }
          },
          {
            name: "pool_status",
            type: {
              defined: {
                name: "PoolStatus"
              }
            }
          }
        ]
      }
    },
    {
      name: "VestingParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_locked_amount",
            type: "u64"
          },
          {
            name: "cliff_period",
            type: "u64"
          },
          {
            name: "unlock_period",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "VestingRecord",
      type: {
        kind: "struct",
        fields: [
          {
            name: "epoch",
            docs: [
              "Account update epoch"
            ],
            type: "u64"
          },
          {
            name: "pool",
            docs: [
              "The pool state account"
            ],
            type: "pubkey"
          },
          {
            name: "beneficiary",
            docs: [
              "The beneficiary of the vesting account"
            ],
            type: "pubkey"
          },
          {
            name: "claimed_amount",
            docs: [
              "The amount of tokens claimed"
            ],
            type: "u64"
          },
          {
            name: "token_share_amount",
            docs: [
              "The share amount of the token to be vested"
            ],
            type: "u64"
          },
          {
            name: "padding",
            docs: [
              "padding for future updates"
            ],
            type: {
              array: [
                "u64",
                8
              ]
            }
          }
        ]
      }
    },
    {
      name: "VestingSchedule",
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_locked_amount",
            type: "u64"
          },
          {
            name: "cliff_period",
            type: "u64"
          },
          {
            name: "unlock_period",
            type: "u64"
          },
          {
            name: "start_time",
            type: "u64"
          },
          {
            name: "allocated_share_amount",
            docs: [
              "Total allocated share amount of the base token, not greater than total_locked_amount"
            ],
            type: "u64"
          }
        ]
      }
    }
  ]
};

// src/transactions/utils.ts
async function createAnchorInitializeInstruction(connection, payer, creator, baseMint, metadataUri, name, symbol, decimals = 6, supply = DEFAULT_SUPPLY, baseSell = DEFAULT_BASE_SELL, quoteRaising = DEFAULT_QUOTE_RAISING) {
  const mockWallet = {
    publicKey: payer,
    signTransaction: async (tx) => tx,
    signAllTransactions: async (txs) => txs
  };
  const provider = new AnchorProvider(connection, mockWallet, {});
  const program = new Program(letsbonk_default, provider);
  const quoteMint = WSOL_TOKEN;
  const [authority] = PDAUtils.findVaultAuthority(LETSBONK_PROGRAM_ID);
  const [globalConfigPDA] = PDAUtils.findGlobalConfig();
  const [platformConfig] = PDAUtils.findPlatformConfig();
  const [eventAuthority] = PDAUtils.findEventAuthority(LETSBONK_PROGRAM_ID);
  const pdas = PDAUtils.deriveAll(baseMint, quoteMint);
  const baseMintParam = {
    decimals,
    name,
    symbol,
    uri: metadataUri
  };
  const curveParam = {
    constant: {
      data: {
        supply: new BN(supply),
        totalBaseSell: new BN(baseSell),
        totalQuoteFundRaising: new BN(quoteRaising),
        migrateType: 1
      }
    }
  };
  const vestingParam = {
    totalLockedAmount: new BN(0),
    cliffPeriod: new BN(0),
    unlockPeriod: new BN(0)
  };
  return await program.methods.initialize(baseMintParam, curveParam, vestingParam).accountsPartial({
    payer,
    creator,
    globalConfig: globalConfigPDA,
    platformConfig,
    authority,
    poolState: pdas.poolState,
    baseMint,
    quoteMint,
    baseVault: pdas.baseVault,
    quoteVault: pdas.quoteVault,
    metadataAccount: pdas.metadata,
    baseTokenProgram: TOKEN_PROGRAM_ID$1,
    quoteTokenProgram: TOKEN_PROGRAM_ID$1,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID$1,
    systemProgram: SystemProgram.programId,
    tokenMetadataProgram: METAPLEX_PROGRAM,
    rent: RENT_SYSVAR,
    eventAuthority,
    program: LETSBONK_PROGRAM_ID
  }).instruction();
}

// src/transactions/builders.ts
async function buildCreateTokenTransaction(connection, payerKeypair, mintKeypair, metadata, launchParams, priorityFees) {
  const { name, symbol, external_url } = metadata;
  let uri;
  if (external_url && external_url.trim() !== "") {
    uri = external_url;
  } else {
    const uploadResult = await uploadTokenMetadata(metadata);
    if (!uploadResult.success) {
      throw new Error(
        `Failed to upload metadata to IPFS: ${uploadResult.error || "Unknown error"}`
      );
    }
    uri = uploadResult.metadataUri;
  }
  const {
    decimals = 6,
    supply = DEFAULT_SUPPLY,
    baseSell = DEFAULT_BASE_SELL,
    quoteRaising = DEFAULT_QUOTE_RAISING
  } = launchParams || {};
  const instructions = [];
  const launchIx = await createAnchorInitializeInstruction(
    connection,
    payerKeypair.publicKey,
    payerKeypair.publicKey,
    // creator
    mintKeypair.publicKey,
    uri,
    name,
    symbol,
    decimals,
    supply,
    baseSell,
    quoteRaising
  );
  instructions.push(launchIx);
  const { address: baseTokenAccount, instruction: baseTokenAccountIx } = await createOrGetTokenAccount(connection, payerKeypair.publicKey, mintKeypair.publicKey);
  if (baseTokenAccountIx) {
    instructions.push(baseTokenAccountIx);
  }
  const transaction = await setupV0Transaction(connection, payerKeypair.publicKey, instructions, priorityFees);
  return { transaction, baseTokenAccount };
}
async function buildBuyTransaction(connection, payerKeypair, mintPubkey, amountIn, minimumAmountOut, priorityFees) {
  const additionalSigners = [];
  const { address: baseTokenAccount, instruction: baseTokenInstruction } = await createOrGetTokenAccount(connection, payerKeypair.publicKey, mintPubkey);
  const { address: wsolTokenAccount, instructions: wsolInstructions } = await createTemporaryWSOLAccount(
    connection,
    payerKeypair.publicKey,
    Number(amountIn) / Math.pow(10, 9)
    // Convert lamports to SOL for WSOL account creation
  );
  const instructions = [];
  if (baseTokenInstruction) {
    instructions.push(baseTokenInstruction);
  }
  instructions.push(...wsolInstructions);
  const pdas = PDAUtils.deriveAll(mintPubkey, WSOL_TOKEN);
  const buyIx = buildBuyInstruction({
    payerPubkey: payerKeypair.publicKey,
    poolStatePDA: pdas.poolState,
    baseVaultPDA: pdas.baseVault,
    quoteVaultPDA: pdas.quoteVault,
    baseMint: mintPubkey,
    baseTokenAccount,
    wsolTokenAccount,
    amountIn,
    // Pass BigInt directly - no conversion!
    minimumAmountOut
    // Pass BigInt directly - no conversion!
  });
  instructions.push(buyIx);
  const closeWSOLIx = getCloseWSOLInstruction(wsolTokenAccount, payerKeypair.publicKey);
  instructions.push(closeWSOLIx);
  const transaction = await setupV0Transaction(connection, payerKeypair.publicKey, instructions, priorityFees);
  return { transaction, additionalSigners };
}
async function buildSellTransaction(connection, payerKeypair, mintPubkey, amountIn, minimumAmountOut, priorityFees) {
  const additionalSigners = [];
  const { address: baseTokenAccount, instruction: baseTokenInstruction } = await createOrGetTokenAccount(connection, payerKeypair.publicKey, mintPubkey);
  const { address: wsolTokenAccount, instructions: wsolInstructions } = await createTemporaryWSOLAccount(
    connection,
    payerKeypair.publicKey,
    0
    // No initial SOL needed for sell
  );
  const instructions = [];
  if (baseTokenInstruction) {
    instructions.push(baseTokenInstruction);
  }
  instructions.push(...wsolInstructions);
  const pdas = PDAUtils.deriveAll(mintPubkey, WSOL_TOKEN);
  const sellIx = buildSellInstruction({
    payerPubkey: payerKeypair.publicKey,
    poolStatePDA: pdas.poolState,
    baseVaultPDA: pdas.baseVault,
    quoteVaultPDA: pdas.quoteVault,
    baseMint: mintPubkey,
    baseTokenAccount,
    wsolTokenAccount,
    amountIn,
    // Pass BigInt directly - no conversion!
    minimumAmountOut
    // Pass BigInt directly - no conversion!
  });
  instructions.push(sellIx);
  const closeWSOLIx = getCloseWSOLInstruction(wsolTokenAccount, payerKeypair.publicKey);
  instructions.push(closeWSOLIx);
  const transaction = await setupV0Transaction(connection, payerKeypair.publicKey, instructions, priorityFees);
  return { transaction, additionalSigners };
}
async function buildInitializeAndBuyTransaction(connection, payer, creator, baseMint, tokenMetadata, buyAmountLamports, launchParams, priorityFees) {
  const { name, symbol, external_url } = tokenMetadata;
  let uri;
  if (external_url && external_url.trim() !== "") {
    uri = external_url;
  } else {
    const uploadResult = await uploadTokenMetadata(tokenMetadata);
    if (!uploadResult.success) {
      throw new Error(
        `Failed to upload metadata to IPFS: ${uploadResult.error || "Unknown error"}`
      );
    }
    uri = uploadResult.metadataUri;
  }
  const {
    decimals = 6,
    supply = DEFAULT_SUPPLY,
    baseSell = DEFAULT_BASE_SELL,
    quoteRaising = DEFAULT_QUOTE_RAISING
  } = launchParams || {};
  const instructions = [];
  const launchIx = await createAnchorInitializeInstruction(
    connection,
    payer.publicKey,
    creator,
    baseMint.publicKey,
    uri,
    name,
    symbol,
    decimals,
    supply,
    baseSell,
    quoteRaising
  );
  instructions.push(launchIx);
  const { address: baseTokenAccount, instruction: baseTokenAccountIx } = await createOrGetTokenAccount(connection, payer.publicKey, baseMint.publicKey);
  if (baseTokenAccountIx) {
    instructions.push(baseTokenAccountIx);
  }
  if (buyAmountLamports && buyAmountLamports > 0n) {
    const buyAmountSol = Number(buyAmountLamports) / Math.pow(10, 9);
    const tokenInfo = calculateTokensReceive(buyAmountSol, 30, 5);
    const tokenDecimals = 6;
    const minimumAmountOutRaw = BigInt(
      Math.round(tokenInfo.tokenAmount * Math.pow(10, tokenDecimals))
    );
    const pdas = PDAUtils.deriveAll(baseMint.publicKey, WSOL_TOKEN);
    const { address: wsolTokenAccount, instructions: wsolInstructions } = await createTemporaryWSOLAccount(
      connection,
      payer.publicKey,
      buyAmountSol
      // Still need SOL amount for WSOL account creation
    );
    instructions.push(...wsolInstructions);
    const buyIx = buildBuyInstruction({
      payerPubkey: payer.publicKey,
      poolStatePDA: pdas.poolState,
      baseVaultPDA: pdas.baseVault,
      quoteVaultPDA: pdas.quoteVault,
      baseMint: baseMint.publicKey,
      baseTokenAccount,
      wsolTokenAccount,
      amountIn: buyAmountLamports,
      // Pass BigInt lamports directly
      minimumAmountOut: minimumAmountOutRaw
      // Pass BigInt raw token amount
    });
    instructions.push(buyIx);
    const closeWSOLIx = getCloseWSOLInstruction(wsolTokenAccount, payer.publicKey);
    instructions.push(closeWSOLIx);
  }
  const transaction = await setupV0Transaction(connection, payer.publicKey, instructions, priorityFees);
  return {
    transaction,
    signers: [payer, baseMint],
    baseTokenAccount
  };
}

// src/transactions/executors.ts
var logger2 = getLogger();
async function sendAndConfirmTransactionWithRetry(connection, transaction, signers, skipPreflight = true, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      transaction.sign(signers);
      const signature = await connection.sendTransaction(transaction, {
        skipPreflight,
        maxRetries: 0
        // We handle retries ourselves
      });
      await connection.confirmTransaction(signature, "confirmed");
      if (attempt > 1) {
        logger2.info(`\u2705 Transaction succeeded on attempt ${attempt}`, { attempt, signature });
      }
      return signature;
    } catch (error) {
      if (attempt === 1) {
        logger2.warn(`\u23F3 Transaction failed, retrying...`, { attempt });
      }
      if (attempt === maxRetries) {
        logger2.error("Transaction failed after all retries", { attempt, maxRetries, error });
        throw error;
      }
      await new Promise((resolve) => setTimeout(resolve, 1e3 * attempt));
    }
  }
  throw new Error("Transaction failed after all retries");
}

// src/transactions/orchestrators.ts
var logger3 = getLogger();
async function orchestrateTokenLaunch(connection, payerKeypair, mintKeypair, metadata, launchParams, buyAmountLamports) {
  try {
    logger3.info(`Creating token: ${metadata.name} (${metadata.symbol})`, {
      name: metadata.name,
      symbol: metadata.symbol,
      mint: mintKeypair.publicKey.toString(),
      buyAmount: buyAmountLamports?.toString()
    });
    if (buyAmountLamports && buyAmountLamports > 0n) {
      const { transaction, signers, baseTokenAccount } = await buildInitializeAndBuyTransaction(
        connection,
        payerKeypair,
        payerKeypair.publicKey,
        // creator is same as payer
        mintKeypair,
        metadata,
        buyAmountLamports,
        launchParams
      );
      const signature = await sendAndConfirmTransactionWithRetry(connection, transaction, signers);
      return {
        success: true,
        signature,
        baseTokenAccount,
        message: `Token ${metadata.symbol} launched and ${buyAmountLamports} lamports worth purchased`,
        transaction,
        signers,
        sentAt: Date.now()
      };
    } else {
      const { transaction: createTokenTxn, baseTokenAccount } = await buildCreateTokenTransaction(
        connection,
        payerKeypair,
        mintKeypair,
        metadata,
        launchParams
      );
      const signature = await sendAndConfirmTransactionWithRetry(connection, createTokenTxn, [
        payerKeypair,
        mintKeypair
      ]);
      return {
        success: true,
        signature,
        baseTokenAccount,
        message: `Token ${metadata.symbol} launched successfully`,
        transaction: createTokenTxn,
        signers: [payerKeypair, mintKeypair],
        sentAt: Date.now()
      };
    }
  } catch (error) {
    logger3.error("Launch token failed", {
      tokenName: metadata.name,
      symbol: metadata.symbol,
      error
    });
    return {
      success: false,
      error: `Launch failed: ${error instanceof Error ? error.message : "Unknown error"}`
    };
  }
}

// src/managers/transaction-manager.ts
var TransactionManager = class {
  constructor(program, connection, logger4) {
    this.program = program;
    this.connection = connection;
    this.logger = logger4.child({ manager: "TransactionManager" });
  }
  logger;
  /**
   * Helper to get instruction count from any transaction type
   */
  getInstructionCount(transaction) {
    return transaction.message.compiledInstructions.length;
  }
  /**
   * Build a buy transaction without executing it
   */
  async buildBuy(params) {
    const timer = this.logger.startTimer("buildBuy");
    const operation = "buy";
    try {
      this.logger.debug("Building buy transaction", {
        operation,
        buyer: params.buyer.publicKey.toString(),
        baseMint: params.baseMint.toString(),
        amountIn: params.amountIn.toString()
      });
      const validation = this.validateBuyParams(params);
      if (!validation.success) {
        return failure(validation.error);
      }
      const buildResult = await tryAsync(
        buildBuyTransaction(
          this.connection,
          params.buyer,
          params.baseMint,
          params.amountIn,
          // Use raw BigInt directly - no precision loss!
          params.minimumAmountOut,
          // Use raw BigInt directly - no precision loss!
          params.priorityFees
        ),
        (error) => new TransactionError(
          `Failed to build buy transaction: ${error.message}`,
          void 0,
          void 0,
          error
        )
      );
      if (!buildResult.success) {
        timer.end({ success: false, error: buildResult.error.message });
        return failure(buildResult.error);
      }
      const { transaction, additionalSigners } = buildResult.data;
      const constructedTransaction = {
        transaction,
        signers: [params.buyer, ...additionalSigners],
        description: `Buy ${params.amountIn} tokens for ${params.baseMint.toString().slice(0, 8)}...`
      };
      timer.end({ success: true });
      this.logger.info("Buy transaction built successfully", {
        operation,
        instructionCount: this.getInstructionCount(transaction),
        signerCount: constructedTransaction.signers.length
      });
      return success(constructedTransaction);
    } catch (error) {
      const txError = new TransactionError(
        `Unexpected error building buy transaction: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(txError, { operation });
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
  /**
   * Build a sell transaction without executing it
   */
  async buildSell(params) {
    const timer = this.logger.startTimer("buildSell");
    const operation = "sell";
    try {
      this.logger.debug("Building sell transaction", {
        operation,
        seller: params.seller.publicKey.toString(),
        baseMint: params.baseMint.toString(),
        amountIn: params.amountIn.toString()
      });
      const validation = this.validateSellParams(params);
      if (!validation.success) {
        return failure(validation.error);
      }
      const buildResult = await tryAsync(
        buildSellTransaction(
          this.connection,
          params.seller,
          params.baseMint,
          params.amountIn,
          // Use raw BigInt directly - no precision loss!
          params.minimumAmountOut,
          // Use raw BigInt directly - no precision loss!
          params.priorityFees
        ),
        (error) => new TransactionError(
          `Failed to build sell transaction: ${error.message}`,
          void 0,
          void 0,
          error
        )
      );
      if (!buildResult.success) {
        timer.end({ success: false, error: buildResult.error.message });
        return failure(buildResult.error);
      }
      const { transaction, additionalSigners } = buildResult.data;
      const constructedTransaction = {
        transaction,
        signers: [params.seller, ...additionalSigners],
        description: `Sell ${params.amountIn} tokens of ${params.baseMint.toString().slice(0, 8)}...`
      };
      timer.end({ success: true });
      this.logger.info("Sell transaction built successfully", {
        operation,
        instructionCount: this.getInstructionCount(transaction),
        signerCount: constructedTransaction.signers.length
      });
      return success(constructedTransaction);
    } catch (error) {
      const txError = new TransactionError(
        `Unexpected error building sell transaction: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(txError, { operation });
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
  /**
   * Build an initialize transaction without executing it
   */
  async buildInitialize(params) {
    const timer = this.logger.startTimer("buildInitialize");
    const operation = "initialize";
    try {
      this.logger.debug("Building initialize transaction", {
        operation,
        creator: params.creator.toString(),
        baseMint: params.baseMint.toString()
      });
      const validation = this.validateInitializeParams(params);
      if (!validation.success) {
        return failure(validation.error);
      }
      const buildResult = await tryAsync(
        buildCreateTokenTransaction(this.connection, params.payer, params.baseMint, params.tokenMetadata),
        (error) => new TransactionError(
          `Failed to build initialize transaction: ${error.message}`,
          void 0,
          void 0,
          error
        )
      );
      if (!buildResult.success) {
        timer.end({ success: false, error: buildResult.error.message });
        return failure(buildResult.error);
      }
      const { transaction, baseTokenAccount } = buildResult.data;
      const constructedTransaction = {
        transaction,
        signers: [params.payer, params.baseMint],
        description: `Initialize pool for ${params.tokenMetadata.symbol}`
      };
      timer.end({ success: true });
      this.logger.info("Initialize transaction built successfully", {
        operation,
        baseMint: params.baseMint.toString(),
        baseTokenAccount: baseTokenAccount?.toString(),
        instructionCount: this.getInstructionCount(transaction)
      });
      return success(constructedTransaction);
    } catch (error) {
      const txError = new TransactionError(
        `Unexpected error building initialize transaction: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(txError, { operation });
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
  /**
   * Execute a pre-built transaction
   */
  async execute(constructedTransaction, options = {}) {
    const timer = this.logger.startTimer("executeTransaction");
    const operation = constructedTransaction.description || "transaction";
    try {
      const {
        skipPreflight = false,
        maxRetries = 3,
        commitment = "confirmed",
        timeout = 6e4
      } = options;
      this.logger.info("Executing transaction", {
        operation,
        instructionCount: this.getInstructionCount(constructedTransaction.transaction),
        skipPreflight,
        maxRetries,
        commitment
      });
      const executeResult = await tryAsync(
        Promise.race([
          sendAndConfirmTransactionWithRetry(
            this.connection,
            constructedTransaction.transaction,
            constructedTransaction.signers,
            skipPreflight,
            maxRetries
          ),
          new Promise(
            (_, reject) => setTimeout(() => reject(new Error("Transaction timeout")), timeout)
          )
        ]),
        (error) => {
          if (error.message.includes("timeout")) {
            return new TimeoutError("Transaction execution timed out", timeout, operation, error);
          }
          return new TransactionError(
            `Transaction execution failed: ${error.message}`,
            void 0,
            void 0,
            error
          );
        }
      );
      if (!executeResult.success) {
        timer.end({ success: false, error: executeResult.error.message });
        return failure(executeResult.error);
      }
      const signature = executeResult.data;
      const result = {
        success: true,
        signature,
        sentAt: Date.now(),
        transaction: constructedTransaction.transaction,
        signers: constructedTransaction.signers,
        description: constructedTransaction.description
      };
      timer.end({ success: true });
      this.logger.info("Transaction executed successfully", {
        operation,
        signature,
        commitment
      });
      return success(result);
    } catch (error) {
      const txError = new TransactionError(
        `Unexpected error executing transaction: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(txError, { operation });
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
  /**
   * Build and execute a buy transaction in one call
   */
  async buyAndExecute(params, options = {}) {
    const buildResult = await this.buildBuy(params);
    if (!buildResult.success) {
      return buildResult;
    }
    return this.execute(buildResult.data, options);
  }
  /**
   * Build and execute a sell transaction in one call
   */
  async sellAndExecute(params, options = {}) {
    const buildResult = await this.buildSell(params);
    if (!buildResult.success) {
      return buildResult;
    }
    return this.execute(buildResult.data, options);
  }
  /**
   * Build and execute an initialize transaction in one call
   */
  async initializeAndExecute(params, options = {}) {
    const buildResult = await this.buildInitialize(params);
    if (!buildResult.success) {
      return buildResult;
    }
    return this.execute(buildResult.data, options);
  }
  /**
   * Build and execute an initialize and buy transaction in one call
   */
  async initializeAndBuyAndExecute(payer, creator, baseMint, tokenMetadata, buyAmountLamports, options = {}) {
    const buildResult = await this.buildInitializeAndBuy(
      payer,
      creator,
      baseMint,
      tokenMetadata,
      buyAmountLamports,
      options.priorityFees
    );
    if (!buildResult.success) {
      return buildResult;
    }
    return this.execute(buildResult.data, options);
  }
  /**
   * Validate buy transaction parameters
   */
  validateBuyParams(params) {
    return SharedValidators.validateBuyParams(params);
  }
  /**
   * Validate sell transaction parameters
   */
  validateSellParams(params) {
    return SharedValidators.validateSellParams(params);
  }
  /**
   * Validate initialize transaction parameters
   */
  validateInitializeParams(params) {
    return SharedValidators.validateInitializeParams(params);
  }
  /**
   * Get transaction status
   */
  async getTransactionStatus(signature) {
    const timer = this.logger.startTimer("getTransactionStatus");
    try {
      this.logger.debug("Fetching transaction status", { signature });
      const result = await tryAsync(
        this.connection.getTransaction(signature, {
          commitment: "confirmed",
          maxSupportedTransactionVersion: 0
        }),
        (error) => new TransactionError(
          `Failed to fetch transaction status: ${error.message}`,
          signature,
          void 0,
          error
        )
      );
      timer.end({ success: result.success });
      return result;
    } catch (error) {
      const txError = new TransactionError(
        `Unexpected error fetching transaction status: ${error instanceof Error ? error.message : "Unknown error"}`,
        signature,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(txError);
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
  /**
   * Build initialize and buy transaction without executing
   *
   * @param payer - Keypair that pays for initialization and buys tokens
   * @param creator - Public key of the token creator
   * @param baseMint - Keypair for the new token mint
   * @param tokenMetadata - Metadata for the new token
   * @param buyAmountLamports - Amount of lamports to spend on buying tokens (in lamports)
   * @param priorityFees - Optional priority fees configuration
   */
  async buildInitializeAndBuy(payer, creator, baseMint, tokenMetadata, buyAmountLamports, priorityFees) {
    const timer = this.logger.startTimer("buildInitializeAndBuy");
    const operation = "buildInitializeAndBuy";
    try {
      this.logger.debug("Building initialize and buy transaction", {
        operation,
        baseMint: baseMint.publicKey.toString(),
        creator: creator.toString(),
        buyAmountLamports: buyAmountLamports.toString()
      });
      const buildResult = await tryAsync(
        buildInitializeAndBuyTransaction(
          this.connection,
          payer,
          creator,
          baseMint,
          tokenMetadata,
          buyAmountLamports,
          void 0,
          // launchParams
          priorityFees
        ),
        (error) => new ValidationError(
          `Failed to build initialize and buy transaction: ${error.message}`,
          void 0,
          { originalError: error.message }
        )
      );
      if (!buildResult.success) {
        timer.end({ success: false, error: buildResult.error.message });
        return failure(buildResult.error);
      }
      const { transaction, signers } = buildResult.data;
      const constructedTransaction = {
        transaction,
        signers,
        description: buyAmountLamports > 0n ? `Initialize ${tokenMetadata.symbol} and buy ${buyAmountLamports} lamports worth of tokens` : `Initialize ${tokenMetadata.symbol}`
      };
      timer.end({ success: true });
      this.logger.info("Initialize and buy transaction built successfully", {
        operation,
        baseMint: baseMint.publicKey.toString(),
        buyAmountLamports: buyAmountLamports.toString(),
        instructionCount: this.getInstructionCount(transaction),
        signerCount: constructedTransaction.signers.length
      });
      return success(constructedTransaction);
    } catch (error) {
      const txError = new ValidationError(
        `Unexpected error building initialize and buy transaction: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        error instanceof Error ? { originalError: error.message } : void 0
      );
      this.logger.logError(txError, { operation });
      timer.end({ success: false, error: txError.message });
      return failure(txError);
    }
  }
};

// src/managers/pool-manager.ts
var PoolManager = class {
  constructor(program, connection, logger4) {
    this.program = program;
    this.connection = connection;
    this.logger = logger4.child({ manager: "PoolManager" });
  }
  logger;
  /**
   * Calculate slippage for buy operations
   */
  calculateBuySlippage(amountIn, slippageBasisPoints = 500n) {
    this.logger.debug("Calculating buy slippage", {
      amountIn: amountIn.toString(),
      slippageBasisPoints: slippageBasisPoints.toString()
    });
    const minimumAmountOut = calculateSlippageBuy(amountIn, slippageBasisPoints);
    const priceImpact = Number(slippageBasisPoints) / 1e4;
    const effectivePrice = Number(amountIn) / Number(minimumAmountOut);
    return {
      minimumAmountOut,
      priceImpact,
      effectivePrice
    };
  }
  /**
   * Calculate slippage for sell operations
   */
  calculateSellSlippage(amountIn, slippageBasisPoints = 500n) {
    this.logger.debug("Calculating sell slippage", {
      amountIn: amountIn.toString(),
      slippageBasisPoints: slippageBasisPoints.toString()
    });
    const minimumAmountOut = calculateSlippageSell(amountIn, slippageBasisPoints);
    const priceImpact = Number(slippageBasisPoints) / 1e4;
    const effectivePrice = Number(amountIn) / Number(minimumAmountOut);
    return {
      minimumAmountOut,
      priceImpact,
      effectivePrice
    };
  }
  /**
   * Calculate tokens received for SOL amount
   */
  calculateTokensForSOL(solAmount, previousSol = 30, slippage = 5) {
    this.logger.debug("Calculating tokens for SOL", {
      solAmount,
      previousSol,
      slippage
    });
    return calculateTokensReceive(solAmount, previousSol, slippage);
  }
  /**
   * Get pool PDAs
   */
  getPoolPDAs(baseMint, quoteMint) {
    this.logger.debug("Getting pool PDAs", {
      baseMint: baseMint.toString(),
      quoteMint: quoteMint.toString()
    });
    return PDAUtils.deriveAll(baseMint, quoteMint);
  }
};

// src/managers/metadata-manager.ts
var MetadataManager = class {
  logger;
  constructor(logger4) {
    this.logger = logger4.child({ manager: "MetadataManager" });
  }
  /**
   * Upload token metadata to IPFS
   */
  async uploadMetadata(metadata) {
    const timer = this.logger.startTimer("uploadMetadata");
    try {
      this.logger.debug("Uploading metadata", {
        name: metadata.name,
        symbol: metadata.symbol,
        hasFile: !!metadata.file
      });
      const validation = this.validateMetadata(metadata);
      if (!validation.success) {
        return validation;
      }
      const uploadResult = await tryAsync(
        uploadTokenMetadata(metadata),
        (error) => new NetworkError(`Failed to upload metadata: ${error.message}`, "ipfs", void 0, error)
      );
      if (!uploadResult.success) {
        timer.end({ success: false, error: uploadResult.error.message });
        return failure(uploadResult.error);
      }
      const result = uploadResult.data;
      timer.end({ success: true });
      this.logger.info("Metadata uploaded successfully", {
        metadataUri: result.metadataUri,
        name: metadata.name,
        symbol: metadata.symbol
      });
      return success(result);
    } catch (error) {
      const networkError = new NetworkError(
        `Unexpected error uploading metadata: ${error instanceof Error ? error.message : "Unknown error"}`,
        "ipfs",
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(networkError);
      timer.end({ success: false, error: networkError.message });
      return failure(networkError);
    }
  }
  /**
   * Prepare metadata from various input formats
   */
  async prepareMetadata(params) {
    const timer = this.logger.startTimer("prepareMetadata");
    try {
      this.logger.debug("Preparing metadata", {
        name: params.name,
        symbol: params.symbol,
        imageInputType: typeof params.imageInput
      });
      const validation = this.validatePreparationParams(params);
      if (!validation.success) {
        timer.end({ success: false, error: validation.error.message });
        return validation;
      }
      const result = await tryAsync(
        prepareTokenMetadata(params),
        (error) => new ValidationError(
          `Failed to prepare metadata: ${error.message}`,
          "preparation",
          params,
          error
        )
      );
      if (!result.success) {
        this.logger.error("Failed to prepare metadata", { error: result.error.message });
        timer.end({ success: false, error: result.error.message });
        return failure(result.error);
      }
      this.logger.info("Metadata prepared successfully", {
        name: result.data.name,
        symbol: result.data.symbol,
        fileSize: result.data.file.size
      });
      timer.end({ success: true });
      return success(result.data);
    } catch (error) {
      const validationError = new ValidationError(
        `Unexpected error preparing metadata: ${error instanceof Error ? error.message : "Unknown error"}`,
        "preparation",
        params,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(validationError);
      timer.end({ success: false, error: validationError.message });
      return failure(validationError);
    }
  }
  /**
   * Create image blob from base64 string
   */
  createImageFromBase64(base64) {
    try {
      this.logger.debug("Creating image blob from base64");
      const blob = createImageBlob(base64);
      this.logger.debug("Image blob created", { size: blob.size });
      return success(blob);
    } catch (error) {
      const validationError = new ValidationError(
        `Failed to create image blob: ${error instanceof Error ? error.message : "Unknown error"}`,
        "base64",
        base64,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(validationError);
      return failure(validationError);
    }
  }
  /**
   * Build image blob from URL
   */
  async buildImageFromUrl(url) {
    const timer = this.logger.startTimer("buildImageFromUrl");
    try {
      this.logger.debug("Creating image blob from URL", { url });
      try {
        new URL(url);
      } catch {
        return failure(new ValidationError("Invalid URL provided", "url", url));
      }
      const result = await tryAsync(
        createImageBlobFromUrl(url),
        (error) => new NetworkError(
          `Failed to fetch image from URL: ${error.message}`,
          url,
          void 0,
          error
        )
      );
      if (!result.success) {
        timer.end({ success: false, error: result.error.message });
        return result;
      }
      this.logger.info("Image blob created from URL", {
        url,
        size: result.data.size
      });
      timer.end({ success: true });
      return result;
    } catch (error) {
      const networkError = new NetworkError(
        `Unexpected error creating image from URL: ${error instanceof Error ? error.message : "Unknown error"}`,
        url,
        void 0,
        error instanceof Error ? error : void 0
      );
      this.logger.logError(networkError);
      timer.end({ success: false, error: networkError.message });
      return failure(networkError);
    }
  }
  /**
   * Validate metadata structure
   */
  validateMetadata(metadata) {
    if (!metadata.name || metadata.name.trim().length === 0) {
      return failure(new ValidationError("Token name is required", "name", metadata.name));
    }
    if (!metadata.symbol || metadata.symbol.trim().length === 0) {
      return failure(new ValidationError("Token symbol is required", "symbol", metadata.symbol));
    }
    if (!metadata.description || metadata.description.trim().length === 0) {
      return failure(
        new ValidationError("Token description is required", "description", metadata.description)
      );
    }
    if (!metadata.file) {
      return failure(new ValidationError("Token image file is required", "file", metadata.file));
    }
    if (metadata.symbol.length > 10) {
      return failure(
        new ValidationError("Token symbol must be 10 characters or less", "symbol", metadata.symbol)
      );
    }
    if (!/^[A-Z0-9]+$/.test(metadata.symbol)) {
      return failure(
        new ValidationError(
          "Token symbol must contain only uppercase letters and numbers",
          "symbol",
          metadata.symbol
        )
      );
    }
    if (metadata.file.size > 1024 * 1024) {
      return failure(
        new ValidationError("Image file must be smaller than 1MB", "file", metadata.file)
      );
    }
    return success(void 0);
  }
  /**
   * Validate preparation parameters
   */
  validatePreparationParams(params) {
    if (!params.name || params.name.trim().length === 0) {
      return failure(new ValidationError("Token name is required", "name", params.name));
    }
    if (!params.symbol || params.symbol.trim().length === 0) {
      return failure(new ValidationError("Token symbol is required", "symbol", params.symbol));
    }
    if (!params.description || params.description.trim().length === 0) {
      return failure(
        new ValidationError("Token description is required", "description", params.description)
      );
    }
    if (!params.imageInput) {
      return failure(
        new ValidationError("Image input is required", "imageInput", params.imageInput)
      );
    }
    if (params.symbol.length > 10) {
      return failure(
        new ValidationError("Token symbol must be 10 characters or less", "symbol", params.symbol)
      );
    }
    if (!/^[A-Z0-9]+$/.test(params.symbol)) {
      return failure(
        new ValidationError(
          "Token symbol must contain only uppercase letters and numbers",
          "symbol",
          params.symbol
        )
      );
    }
    return success(void 0);
  }
};

export { ALT_ACCOUNT_ADDRESS, ASSOCIATED_TOKEN_PROGRAM_ID, AccountManager, BUY_EXACT_IN_DISCRIMINATOR, BaseManager, DEFAULT_BASE_SELL, DEFAULT_COMMITMENT, DEFAULT_FINALITY, DEFAULT_MAX_RETRIES, DEFAULT_QUOTE_RAISING, DEFAULT_SHARE_FEE_RATE, DEFAULT_SLIPPAGE_BASIS_POINTS, DEFAULT_SUPPLY, DEFAULT_TIMEOUT_MS, EVENT_AUTHORITY, EVENT_AUTHORITY_SEED, GLOBAL_CONFIG, GLOBAL_CONFIG_SEED, GLOBAL_CONFIG_SIZE, INITIALIZE_DISCRIMINATOR, LETSBONK_PROGRAM_ID, METADATA_SEED, METAPLEX_PROGRAM, MetadataManager, PDAUtils, PDA_SEEDS, PLATFORM_ADMIN, PLATFORM_CONFIG, PLATFORM_CONFIG_SEED, PLATFORM_CONFIG_SIZE, POOL_SEED, POOL_STATE_SIZE, POOL_VAULT_SEED, POOL_VESTING_SEED, PoolManager, RAYDIUM_AUTHORITY, RENT_SYSVAR, SDK_NAME, SDK_VERSION, SELL_EXACT_IN_DISCRIMINATOR, SOL_DECIMAL, SYSTEM_PROGRAM_ID, SharedValidators, TOKEN_DECIMAL, TOKEN_PROGRAM_ID, TransactionManager, UNIT_BUDGET, UNIT_PRICE, VAULT_AUTH_SEED, WSOL_TOKEN, basisPointsToPercentage, bufferFromString, buildBuyInstruction, buildBuyTransaction, buildCreateTokenTransaction, buildInitializeAndBuyTransaction, buildLaunchInstruction, buildSellInstruction, buildSellTransaction, calculateMinimumAmountOut, calculateSlippageBuy, calculateSlippageSell, calculateTokensReceive, createAnchorInitializeInstruction, createImageBlob, createImageBlobFromUrl, createOrGetTokenAccount, createTemporaryWSOLAccount, fetchAltAccount, getAltAccountPublicKey, getCloseWSOLInstruction, isValidPublicKey, letsbonk_default, orchestrateTokenLaunch, percentageToBasisPoints, prepareTokenMetadata, sendAndConfirmTransactionWithRetry, setupV0Transaction, uploadTokenMetadata };
//# sourceMappingURL=chunk-ZTPAJDST.mjs.map
//# sourceMappingURL=chunk-ZTPAJDST.mjs.map