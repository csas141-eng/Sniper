import pino from 'pino';

/* LetsBonkSDK - Modern TypeScript Web3 SDK */

// src/core/errors.ts
var SDKError = class extends Error {
  constructor(message, cause, context) {
    super(message);
    this.cause = cause;
    this.context = context;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  /**
   * Convert error to JSON for logging/serialization
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      category: this.category,
      context: this.context,
      stack: this.stack,
      cause: this.cause ? {
        name: this.cause.name,
        message: this.cause.message,
        stack: this.cause.stack
      } : void 0
    };
  }
};
var ConfigurationError = class extends SDKError {
  code = "CONFIGURATION_ERROR";
  category = "configuration" /* Configuration */;
};
var ValidationError = class extends SDKError {
  constructor(message, field, value, cause) {
    super(message, cause, { field, value });
    this.field = field;
    this.value = value;
  }
  code = "VALIDATION_ERROR";
  category = "validation" /* Validation */;
};
var NetworkError = class extends SDKError {
  constructor(message, endpoint, statusCode, cause) {
    super(message, cause, { endpoint, statusCode });
    this.endpoint = endpoint;
    this.statusCode = statusCode;
  }
  code = "NETWORK_ERROR";
  category = "network" /* Network */;
};
var TransactionError = class extends SDKError {
  constructor(message, signature, instructionIndex, cause) {
    super(message, cause, { signature, instructionIndex });
    this.signature = signature;
    this.instructionIndex = instructionIndex;
  }
  code = "TRANSACTION_ERROR";
  category = "transaction" /* Transaction */;
};
var AccountError = class extends SDKError {
  constructor(message, address, accountType, cause) {
    super(message, cause, { address, accountType });
    this.address = address;
    this.accountType = accountType;
  }
  code = "ACCOUNT_ERROR";
  category = "account" /* Account */;
};
var ProgramError = class extends SDKError {
  constructor(message, programId, instructionName, errorCode, cause) {
    super(message, cause, { programId, instructionName, errorCode });
    this.programId = programId;
    this.instructionName = instructionName;
    this.errorCode = errorCode;
  }
  code = "PROGRAM_ERROR";
  category = "program" /* Program */;
};
var TimeoutError = class extends SDKError {
  constructor(message, timeoutMs, operation, cause) {
    super(message, cause, { timeoutMs, operation });
    this.timeoutMs = timeoutMs;
    this.operation = operation;
  }
  code = "TIMEOUT_ERROR";
  category = "timeout" /* Timeout */;
};
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {
  ErrorCategory2["Configuration"] = "configuration";
  ErrorCategory2["Validation"] = "validation";
  ErrorCategory2["Network"] = "network";
  ErrorCategory2["Transaction"] = "transaction";
  ErrorCategory2["Account"] = "account";
  ErrorCategory2["Program"] = "program";
  ErrorCategory2["Timeout"] = "timeout";
  ErrorCategory2["Unknown"] = "unknown";
  return ErrorCategory2;
})(ErrorCategory || {});
function success(data) {
  return { success: true, data };
}
function failure(error) {
  return { success: false, error };
}
async function tryAsync(promise, errorMapper) {
  try {
    const data = await promise;
    return success(data);
  } catch (error) {
    const sdkError = errorMapper ? errorMapper(error) : new ValidationError("Unknown error occurred", void 0, void 0, error);
    return failure(sdkError);
  }
}
function trySync(fn, errorMapper) {
  try {
    const data = fn();
    return success(data);
  } catch (error) {
    const sdkError = errorMapper ? errorMapper(error) : new ValidationError("Unknown error occurred", void 0, void 0, error);
    return failure(sdkError);
  }
}
function isSDKError(error) {
  return error instanceof SDKError;
}
function isConfigurationError(error) {
  return error instanceof ConfigurationError;
}
function isValidationError(error) {
  return error instanceof ValidationError;
}
function isNetworkError(error) {
  return error instanceof NetworkError;
}
function isTransactionError(error) {
  return error instanceof TransactionError;
}
function isAccountError(error) {
  return error instanceof AccountError;
}
function isProgramError(error) {
  return error instanceof ProgramError;
}
function isTimeoutError(error) {
  return error instanceof TimeoutError;
}
var SDKLogger = class _SDKLogger {
  logger;
  config;
  static instance;
  constructor(config) {
    this.config = config;
    this.logger = this.createLogger();
  }
  /**
   * Get singleton instance (used internally by SDK)
   */
  static getInstance(config) {
    if (!_SDKLogger.instance && config) {
      _SDKLogger.instance = new _SDKLogger(config);
    }
    if (!_SDKLogger.instance) {
      _SDKLogger.instance = new _SDKLogger({
        level: "silent",
        enabled: false,
        prettyPrint: false
      });
    }
    return _SDKLogger.instance;
  }
  /**
   * Create a new logger instance
   */
  static create(config) {
    return new _SDKLogger(config);
  }
  /**
   * Reset singleton instance
   */
  static reset() {
    _SDKLogger.instance = void 0;
  }
  /**
   * Create pino logger with configuration
   */
  createLogger() {
    if (!this.config.enabled) {
      return pino({ level: "silent" });
    }
    const pinoOptions = {
      level: this.config.level,
      name: "letsbonkdotfun-sdk",
      base: {
        version: "1.0.0",
        sdk: "letsbonk",
        ...this.config.context
      }
    };
    const isTestEnv = process.env.NODE_ENV === "test" || process.env.JEST_WORKER_ID !== void 0;
    const shouldUsePrettyPrint = this.config.prettyPrint && !isTestEnv;
    if (shouldUsePrettyPrint) {
      try {
        pinoOptions.transport = {
          target: "pino-pretty",
          options: {
            colorize: true,
            translateTime: "HH:MM:ss Z",
            ignore: "pid,hostname",
            messageFormat: "{sdk} [{level}] {operation}: {msg}"
          }
        };
        return pino(pinoOptions);
      } catch (error) {
        console.warn("pino-pretty transport failed, falling back to simple logging:", error);
      }
    }
    return pino(pinoOptions);
  }
  /**
   * Create child logger with additional context
   */
  child(context) {
    const childLogger = this.logger.child(context);
    const childInstance = Object.create(this);
    childInstance.logger = childLogger;
    return childInstance;
  }
  /**
   * Log error message
   */
  error(message, context) {
    this.logger.error(context || {}, message);
  }
  /**
   * Log warning message
   */
  warn(message, context) {
    this.logger.warn(context || {}, message);
  }
  /**
   * Log info message
   */
  info(message, context) {
    this.logger.info(context || {}, message);
  }
  /**
   * Log debug message
   */
  debug(message, context) {
    this.logger.debug(context || {}, message);
  }
  /**
   * Log trace message
   */
  trace(message, context) {
    this.logger.trace(context || {}, message);
  }
  /**
   * Start performance timer
   */
  startTimer(operation, context) {
    const startTime = Date.now();
    this.debug(`Starting ${operation}`, {
      operation,
      timestamp: startTime,
      ...context
    });
    return {
      end: (endContext) => {
        const endTime = Date.now();
        const duration = endTime - startTime;
        this.info(`Completed ${operation}`, {
          operation,
          duration,
          startTime,
          endTime,
          ...context,
          ...endContext
        });
      }
    };
  }
  /**
   * Log transaction lifecycle events
   */
  logTransaction(event, context) {
    const logContext = {
      ...context,
      event,
      timestamp: Date.now()
    };
    switch (event) {
      case "building":
        this.debug("Building transaction", logContext);
        break;
      case "built":
        this.info("Transaction built successfully", logContext);
        break;
      case "signing":
        this.debug("Signing transaction", logContext);
        break;
      case "sending":
        this.info("Sending transaction", logContext);
        break;
      case "sent":
        this.info("Transaction sent", logContext);
        break;
      case "confirming":
        this.debug("Confirming transaction", logContext);
        break;
      case "confirmed":
        this.info("Transaction confirmed", logContext);
        break;
      case "failed":
        this.error("Transaction failed", logContext);
        break;
      default:
        this.debug("Transaction event", logContext);
    }
  }
  /**
   * Log API calls
   */
  logApiCall(method, endpoint, context) {
    return this.startTimer(`API ${method}`, {
      method,
      endpoint,
      ...context
    });
  }
  /**
   * Log account operations
   */
  logAccount(operation, address, context) {
    this.info(`Account ${operation}`, {
      operation,
      address,
      ...context
    });
  }
  /**
   * Log pool operations
   */
  logPool(operation, poolAddress, context) {
    this.info(`Pool ${operation}`, {
      operation,
      poolAddress,
      ...context
    });
  }
  /**
   * Log trade operations
   */
  logTrade(operation, context) {
    this.info(`Trade ${operation}`, {
      operation,
      ...context
    });
  }
  /**
   * Log errors with stack trace
   */
  logError(error, context) {
    this.error(error.message, {
      ...context,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    });
  }
  /**
   * Log configuration changes
   */
  logConfig(message, config) {
    this.info(message, { config });
  }
  /**
   * Get current log level
   */
  getLevel() {
    return this.config.level;
  }
  /**
   * Check if logging is enabled for a level
   */
  isLevelEnabled(level) {
    if (!this.config.enabled) return false;
    return this.logger.isLevelEnabled(level);
  }
  /**
   * Update logger configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.logger = this.createLogger();
  }
};
function createLogger(config) {
  return SDKLogger.create(config);
}
function getLogger() {
  return SDKLogger.getInstance();
}
var LOG_LEVEL_PRIORITIES = {
  silent: 70,
  error: 50,
  warn: 40,
  info: 30,
  debug: 20,
  trace: 10
};

export { AccountError, ConfigurationError, ErrorCategory, LOG_LEVEL_PRIORITIES, NetworkError, ProgramError, SDKError, SDKLogger, TimeoutError, TransactionError, ValidationError, createLogger, failure, getLogger, isAccountError, isConfigurationError, isNetworkError, isProgramError, isSDKError, isTimeoutError, isTransactionError, isValidationError, success, tryAsync, trySync };
//# sourceMappingURL=chunk-UUBQRI4N.mjs.map
//# sourceMappingURL=chunk-UUBQRI4N.mjs.map