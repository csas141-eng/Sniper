import { ConfigManager } from './chunk-KY4IAQMX.mjs';
export { ConfigManager, DEFAULT_CONFIG } from './chunk-KY4IAQMX.mjs';
import { letsbonk_default, AccountManager, TransactionManager, PoolManager, MetadataManager } from './chunk-ZTPAJDST.mjs';
export { ALT_ACCOUNT_ADDRESS, ASSOCIATED_TOKEN_PROGRAM_ID, AccountManager, BUY_EXACT_IN_DISCRIMINATOR, BaseManager, DEFAULT_BASE_SELL, DEFAULT_COMMITMENT, DEFAULT_FINALITY, DEFAULT_MAX_RETRIES, DEFAULT_QUOTE_RAISING, DEFAULT_SHARE_FEE_RATE, DEFAULT_SLIPPAGE_BASIS_POINTS, DEFAULT_SUPPLY, DEFAULT_TIMEOUT_MS, EVENT_AUTHORITY, EVENT_AUTHORITY_SEED, GLOBAL_CONFIG, GLOBAL_CONFIG_SEED, GLOBAL_CONFIG_SIZE, letsbonk_default as IDL, INITIALIZE_DISCRIMINATOR, LETSBONK_PROGRAM_ID, METADATA_SEED, METAPLEX_PROGRAM, MetadataManager, PDAUtils, PDA_SEEDS, PLATFORM_ADMIN, PLATFORM_CONFIG, PLATFORM_CONFIG_SEED, PLATFORM_CONFIG_SIZE, POOL_SEED, POOL_STATE_SIZE, POOL_VAULT_SEED, POOL_VESTING_SEED, PoolManager, RAYDIUM_AUTHORITY, RENT_SYSVAR, SDK_NAME, SDK_VERSION, SELL_EXACT_IN_DISCRIMINATOR, SOL_DECIMAL, SYSTEM_PROGRAM_ID, SharedValidators, TOKEN_DECIMAL, TOKEN_PROGRAM_ID, TransactionManager, UNIT_BUDGET, UNIT_PRICE, VAULT_AUTH_SEED, WSOL_TOKEN, basisPointsToPercentage, bufferFromString, buildBuyInstruction, buildBuyTransaction, buildInitializeAndBuyTransaction, buildLaunchInstruction, buildSellInstruction, buildSellTransaction, buildCreateTokenTransaction as buildTokenTransaction, calculateMinimumAmountOut, calculateSlippageBuy, calculateSlippageSell, calculateTokensReceive, createAnchorInitializeInstruction, createImageBlob, createImageBlobFromUrl, createOrGetTokenAccount, createTemporaryWSOLAccount, fetchAltAccount, getAltAccountPublicKey, getCloseWSOLInstruction, isValidPublicKey, orchestrateTokenLaunch, percentageToBasisPoints, prepareTokenMetadata, sendAndConfirmTransactionWithRetry, setupV0Transaction, uploadTokenMetadata } from './chunk-ZTPAJDST.mjs';
import { SDKLogger } from './chunk-UUBQRI4N.mjs';
export { AccountError, ConfigurationError, ErrorCategory, LOG_LEVEL_PRIORITIES, NetworkError, ProgramError, SDKError, SDKLogger, TimeoutError, TransactionError, ValidationError, createLogger, failure, getLogger, isAccountError, isConfigurationError, isNetworkError, isProgramError, isSDKError, isTimeoutError, isTransactionError, isValidationError, success, tryAsync, trySync } from './chunk-UUBQRI4N.mjs';
import { Program } from '@coral-xyz/anchor';

/* LetsBonkSDK - Modern TypeScript Web3 SDK */

// src/constants/trading.ts
var MIN_SOL_AMOUNT = 1e-3;
var MAX_SLIPPAGE_BASIS_POINTS = 5000n;
var DEFAULT_PRIORITY_FEE = 5e3;
var INITIAL_VIRTUAL_BASE_RESERVES = 1073000000n;
var INITIAL_VIRTUAL_QUOTE_RESERVES = 30000000000n;
var INITIAL_REAL_BASE_RESERVES = 0n;
var INITIAL_REAL_QUOTE_RESERVES = 0n;
var PLATFORM_FEE_BASIS_POINTS = 100n;
var PROTOCOL_FEE_BASIS_POINTS = 25n;

// src/constants/network.ts
var MAINNET_ENDPOINT = "https://api.mainnet-beta.solana.com";
var DEVNET_ENDPOINT = "https://api.devnet.solana.com";
var TESTNET_ENDPOINT = "https://api.testnet.solana.com";
var LOCALNET_ENDPOINT = "http://localhost:8899";
var ERROR_CODES = {
  CONFIGURATION_ERROR: "CONFIGURATION_ERROR",
  VALIDATION_ERROR: "VALIDATION_ERROR",
  NETWORK_ERROR: "NETWORK_ERROR",
  TRANSACTION_ERROR: "TRANSACTION_ERROR",
  ACCOUNT_ERROR: "ACCOUNT_ERROR",
  PROGRAM_ERROR: "PROGRAM_ERROR",
  TIMEOUT_ERROR: "TIMEOUT_ERROR"
};
var LOG_LEVEL_NAMES = {
  SILENT: "silent",
  ERROR: "error",
  WARN: "warn",
  INFO: "info",
  DEBUG: "debug",
  TRACE: "trace"
};
var EVENT_NAMES = {
  // Configuration events
  CONFIG_CREATED: "config:created",
  CONFIG_UPDATED: "config:updated",
  // Transaction events
  TRANSACTION_BUILDING: "transaction:building",
  TRANSACTION_BUILT: "transaction:built",
  TRANSACTION_SIGNING: "transaction:signing",
  TRANSACTION_SENDING: "transaction:sending",
  TRANSACTION_SENT: "transaction:sent",
  TRANSACTION_CONFIRMING: "transaction:confirming",
  TRANSACTION_CONFIRMED: "transaction:confirmed",
  TRANSACTION_FAILED: "transaction:failed",
  // Trade events
  TRADE_BUY_STARTED: "trade:buy_started",
  TRADE_BUY_COMPLETED: "trade:buy_completed",
  TRADE_SELL_STARTED: "trade:sell_started",
  TRADE_SELL_COMPLETED: "trade:sell_completed",
  // Pool events
  POOL_INITIALIZING: "pool:initializing",
  POOL_INITIALIZED: "pool:initialized",
  POOL_STATE_FETCHED: "pool:state_fetched",
  // Account events
  ACCOUNT_CREATED: "account:created",
  ACCOUNT_FETCHED: "account:fetched",
  // Metadata events
  METADATA_UPLOADING: "metadata:uploading",
  METADATA_UPLOADED: "metadata:uploaded",
  // Error events
  ERROR: "error",
  // Performance events
  PERFORMANCE_MEASUREMENT: "performance:measurement"
};

// src/constants/metadata.ts
var MAX_METADATA_SIZE = 1e3;
var MAX_IMAGE_SIZE = 10 * 1024 * 1024;
var SUPPORTED_IMAGE_TYPES = ["image/jpeg", "image/png", "image/gif", "image/webp"];

// src/letsbonk-sdk.ts
var LetsBonkSDK = class {
  config;
  program;
  logger;
  // Public manager instances
  accounts;
  transactions;
  pools;
  metadata;
  /**
   * Create a new LetsBonkSDK instance
   * 
   * @param connection - Solana connection (REQUIRED)
   * @param config - SDK configuration (optional)
   */
  constructor(connection, config = {}) {
    this.config = ConfigManager.create(connection, config);
    this.logger = SDKLogger.create({
      level: this.config.logging?.level || "info",
      enabled: this.config.logging?.enabled ?? true,
      prettyPrint: this.config.logging?.prettyPrint ?? false,
      context: this.config.logging?.context || {}
    });
    this.logger.info("Initializing LetsBonkSDK", {
      endpoint: this.config.connection.rpcEndpoint
    });
    this.program = new Program(
      letsbonk_default,
      this.config.provider
    );
    this.accounts = new AccountManager(
      this.program,
      this.config.connection,
      this.logger
    );
    this.transactions = new TransactionManager(
      this.program,
      this.config.connection,
      this.logger
    );
    this.pools = new PoolManager(
      this.program,
      this.config.connection,
      this.logger
    );
    this.metadata = new MetadataManager(
      this.logger
    );
    this.logger.info("LetsBonkSDK initialized successfully", {
      version: "2.0.0",
      programId: this.config.programId.toString()
    });
  }
  // === High-level trading methods ===
  /**
   * Buy tokens - builds and executes buy transaction
   * 
   * @param buyer - Keypair of the buyer
   * @param baseMint - Public key of the base token mint
   * @param amountIn - Amount of quote tokens (SOL) to spend
   * @param minimumAmountOut - Minimum tokens to receive (optional)
   * @param options - Transaction execution options including priority fees
   */
  async buy(buyer, baseMint, amountIn, minimumAmountOut, options) {
    const params = {
      buyer,
      baseMint,
      amountIn,
      minimumAmountOut: minimumAmountOut || 0n,
      priorityFees: options?.priorityFees
    };
    return this.transactions.buyAndExecute(params, options);
  }
  /**
   * Sell tokens - builds and executes sell transaction
   * 
   * @param seller - Keypair of the seller
   * @param baseMint - Public key of the base token mint
   * @param amountIn - Amount of base tokens to sell
   * @param minimumAmountOut - Minimum quote tokens (SOL) to receive (optional)
   * @param options - Transaction execution options including priority fees
   */
  async sell(seller, baseMint, amountIn, minimumAmountOut, options) {
    const params = {
      seller,
      baseMint,
      amountIn,
      minimumAmountOut: minimumAmountOut || 0n,
      priorityFees: options?.priorityFees
    };
    return this.transactions.sellAndExecute(params, options);
  }
  /**
   * Initialize a new token pool
   * 
   * @param payer - Keypair that pays for initialization
   * @param creator - Public key of the token creator
   * @param baseMint - Keypair for the new token mint
   * @param tokenMetadata - Metadata for the new token
   * @param options - Transaction execution options including priority fees
   */
  async initialize(payer, creator, baseMint, tokenMetadata, options) {
    const params = {
      payer,
      creator,
      baseMint,
      tokenMetadata,
      priorityFees: options?.priorityFees
    };
    return this.transactions.initializeAndExecute(params, options);
  }
  /**
   * Initialize and buy tokens in a single transaction
   * This is a convenience method that builds and executes the transaction
   * 
   * @param payer - Keypair that pays for the transaction
   * @param creator - Public key of the token creator
   * @param baseMint - Keypair for the new token mint  
   * @param tokenMetadata - Metadata for the new token
   * @param buyAmountLamports - Amount of lamports to spend on buying tokens
   * @param options - Transaction execution options
   */
  async initializeAndBuy(payer, creator, baseMint, tokenMetadata, buyAmountLamports, options) {
    this.logger.info("Starting atomic initializeAndBuy operation", {
      baseMint: baseMint.publicKey.toString(),
      creator: creator.toString(),
      buyAmountLamports: buyAmountLamports.toString()
    });
    return this.transactions.initializeAndBuyAndExecute(
      payer,
      creator,
      baseMint,
      tokenMetadata,
      buyAmountLamports,
      options
    );
  }
  // === Transaction building (for advanced usage) ===
  /**
   * Build buy transaction without executing
   * Note: Priority fees can be specified in the BuyParams.priorityFees field
   * 
   * @param params - Buy parameters including optional priority fees
   */
  async buildBuy(params) {
    return this.transactions.buildBuy(params);
  }
  /**
   * Build sell transaction without executing
   * Note: Priority fees can be specified in the SellParams.priorityFees field
   * 
   * @param params - Sell parameters including optional priority fees
   */
  async buildSell(params) {
    return this.transactions.buildSell(params);
  }
  /**
   * Build initialize transaction without executing
   * Note: Priority fees can be specified in the InitializeParams.priorityFees field
   * 
   * @param params - Initialize parameters including optional priority fees
   */
  async buildInitialize(params) {
    return this.transactions.buildInitialize(params);
  }
  /**
   * Build initialize and buy transaction without executing
   * 
   * @param params - Initialize and buy parameters including optional priority fees
   */
  async buildInitializeAndBuy(params) {
    return this.transactions.buildInitializeAndBuy(
      params.payer,
      params.creator,
      params.baseMint,
      params.tokenMetadata,
      params.buyAmountLamports,
      params.priorityFees
    );
  }
  /**
   * Execute a pre-built transaction
   * 
   * @param transaction - Pre-built transaction to execute
   * @param options - Transaction execution options including priority fees
   */
  async executeTransaction(transaction, options) {
    return this.transactions.execute(transaction, options);
  }
  // === Account operations ===
  /**
   * Get global configuration
   */
  async getGlobalConfig(quoteMint, curveType = 0, index = 0) {
    return this.accounts.getGlobalConfig(quoteMint, curveType, index);
  }
  /**
   * Get platform configuration
   */
  async getPlatformConfig(platformAdmin, index = 0) {
    return this.accounts.getPlatformConfig(platformAdmin, index);
  }
  /**
   * Get pool state
   */
  async getPoolState(baseMint, quoteMint) {
    return this.accounts.getPoolState(baseMint, quoteMint);
  }
  /**
   * Check if pool exists
   */
  async isPoolExists(baseMint, quoteMint) {
    return this.accounts.poolExists(baseMint, quoteMint);
  }
  // === Metadata operations ===
  /**
   * Prepare metadata from various inputs
   */
  async prepareMetadata(params) {
    return this.metadata.prepareMetadata(params);
  }
  /**
   * Upload metadata to IPFS
   */
  async uploadMetadata(metadata) {
    return this.metadata.uploadMetadata(metadata);
  }
  // === Pool utilities ===
  /**
   * Calculate slippage for buy operations
   */
  calculateBuySlippage(amountIn, slippageBasisPoints = 500n) {
    return this.pools.calculateBuySlippage(amountIn, slippageBasisPoints);
  }
  /**
   * Calculate slippage for sell operations
   */
  calculateSellSlippage(amountIn, slippageBasisPoints = 500n) {
    return this.pools.calculateSellSlippage(amountIn, slippageBasisPoints);
  }
  /**
   * Calculate tokens received for SOL amount
   */
  calculateTokensForSOL(solAmount, previousSol = 30, slippage = 5) {
    return this.pools.calculateTokensForSOL(solAmount, previousSol, slippage);
  }
  // === Getter properties for backward compatibility ===
  /**
   * Get connection instance
   */
  get connection() {
    return this.config.connection;
  }
  /**
   * Get commitment level
   */
  get commitment() {
    return this.config.commitment;
  }
  /**
   * Get finality level
   */
  get finality() {
    return this.config.finality;
  }
  // === Configuration access methods ===
  /**
   * Get full resolved configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Get connection instance
   */
  getConnection() {
    return this.config.connection;
  }
  /**
   * Get program instance
   */
  getProgram() {
    return this.program;
  }
  /**
   * Get logger instance
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Get all managers
   */
  getManagers() {
    return {
      accounts: this.accounts,
      transactions: this.transactions,
      pools: this.pools,
      metadata: this.metadata
    };
  }
  /**
   * Update configuration
   */
  updateConfig(newConfig) {
    this.logger.info("Updating SDK configuration", { newConfig });
    this.logger.warn("Configuration updates require SDK reinitialization");
  }
  /**
   * Dispose resources and cleanup
   */
  dispose() {
    this.logger.info("Disposing LetsBonkSDK");
    SDKLogger.reset();
    this.logger.info("LetsBonkSDK disposed");
  }
};

// src/factory.ts
function createSDK(connection, config = {}) {
  return new LetsBonkSDK(connection, config);
}

// src/utils/general.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1e3) {
  let lastError;
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i === maxRetries - 1) {
        throw lastError;
      }
      const delay = baseDelay * Math.pow(2, i);
      await sleep(delay);
    }
  }
  throw lastError;
}

export { DEFAULT_PRIORITY_FEE, DEVNET_ENDPOINT, ERROR_CODES, EVENT_NAMES, INITIAL_REAL_BASE_RESERVES, INITIAL_REAL_QUOTE_RESERVES, INITIAL_VIRTUAL_BASE_RESERVES, INITIAL_VIRTUAL_QUOTE_RESERVES, LOCALNET_ENDPOINT, LOG_LEVEL_NAMES, LetsBonkSDK, MAINNET_ENDPOINT, MAX_IMAGE_SIZE, MAX_METADATA_SIZE, MAX_SLIPPAGE_BASIS_POINTS, MIN_SOL_AMOUNT, PLATFORM_FEE_BASIS_POINTS, PROTOCOL_FEE_BASIS_POINTS, SUPPORTED_IMAGE_TYPES, TESTNET_ENDPOINT, createSDK, retryWithBackoff, sleep };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map