import { ValidationError, ConfigurationError } from './chunk-UUBQRI4N.mjs';
import { PublicKey } from '@solana/web3.js';
import { AnchorProvider } from '@coral-xyz/anchor';
import { z } from 'zod';

/* LetsBonkSDK - Modern TypeScript Web3 SDK */
var LetsBonkConfigSchema = z.object({
  // Program configuration
  programId: z.instanceof(PublicKey).optional(),
  // Connection settings
  commitment: z.enum(["processed", "confirmed", "finalized"]).optional(),
  finality: z.enum(["confirmed", "finalized"]).optional(),
  // Performance configuration
  retries: z.object({
    maxRetries: z.number().min(0).optional(),
    baseDelay: z.number().min(0).optional(),
    maxDelay: z.number().min(0).optional(),
    backoffMultiplier: z.number().min(1).optional()
  }).optional(),
  timeouts: z.object({
    connection: z.number().min(0).optional(),
    transaction: z.number().min(0).optional(),
    confirmation: z.number().min(0).optional()
  }).optional(),
  logging: z.object({
    level: z.enum(["silent", "error", "warn", "info", "debug", "trace"]).optional(),
    enabled: z.boolean().optional(),
    prettyPrint: z.boolean().optional(),
    context: z.record(z.any()).optional()
  }).optional(),
  // Advanced configuration
  skipPreflight: z.boolean().optional(),
  maxConcurrentRequests: z.number().min(1).optional()
});
var DEFAULT_CONFIG = {
  commitment: "confirmed",
  finality: "confirmed",
  programId: new PublicKey("11111111111111111111111111111111"),
  // Placeholder
  retries: {
    maxRetries: 3,
    baseDelay: 1e3,
    maxDelay: 1e4,
    backoffMultiplier: 2
  },
  timeouts: {
    connection: 3e4,
    transaction: 6e4,
    confirmation: 12e4
  },
  logging: (() => {
    const isTestEnv = process.env.NODE_ENV === "test" || process.env.JEST_WORKER_ID !== void 0;
    return {
      level: isTestEnv ? "error" : "info",
      enabled: true,
      prettyPrint: !isTestEnv,
      context: {}
    };
  })(),
  skipPreflight: false,
  maxConcurrentRequests: 10
};
var ConfigManager = class _ConfigManager {
  static instance;
  config = null;
  constructor() {
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_ConfigManager.instance) {
      _ConfigManager.instance = new _ConfigManager();
    }
    return _ConfigManager.instance;
  }
  /**
   * Create configuration from connection and optional config
   */
  static create(connection, userConfig = {}) {
    const manager = _ConfigManager.getInstance();
    return manager.createConfig(connection, userConfig);
  }
  /**
   * Internal method to create and validate configuration
   */
  createConfig(connection, userConfig) {
    try {
      const validatedConfig = this.validateConfig(userConfig);
      const mergedConfig = this.mergeWithDefaults(validatedConfig);
      const provider = this.createProvider(connection, mergedConfig);
      const resolvedConfig = {
        ...mergedConfig,
        provider,
        connection
      };
      this.config = resolvedConfig;
      return resolvedConfig;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError(
          `Configuration validation failed: ${error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ")}`,
          "config",
          userConfig,
          error
        );
      }
      throw new ConfigurationError(
        "Failed to create configuration",
        error instanceof Error ? error : new Error(String(error)),
        { userConfig }
      );
    }
  }
  /**
   * Validate user configuration
   */
  validateConfig(config) {
    return LetsBonkConfigSchema.parse(config);
  }
  /**
   * Merge user configuration with defaults
   */
  mergeWithDefaults(config) {
    return {
      commitment: config.commitment || DEFAULT_CONFIG.commitment,
      finality: config.finality || DEFAULT_CONFIG.finality,
      programId: config.programId || DEFAULT_CONFIG.programId,
      retries: { ...DEFAULT_CONFIG.retries, ...config.retries },
      timeouts: { ...DEFAULT_CONFIG.timeouts, ...config.timeouts },
      logging: { ...DEFAULT_CONFIG.logging, ...config.logging },
      skipPreflight: config.skipPreflight ?? DEFAULT_CONFIG.skipPreflight,
      maxConcurrentRequests: config.maxConcurrentRequests || DEFAULT_CONFIG.maxConcurrentRequests
    };
  }
  /**
   * Create provider with dummy wallet for Anchor program initialization
   */
  createProvider(connection, config) {
    const dummyWallet = {
      publicKey: new PublicKey("11111111111111111111111111111111"),
      signTransaction: () => Promise.reject(new Error("Read-only wallet")),
      signAllTransactions: () => Promise.reject(new Error("Read-only wallet")),
      payer: new PublicKey("11111111111111111111111111111111")
    };
    return new AnchorProvider(connection, dummyWallet, {
      commitment: config.commitment,
      skipPreflight: config.skipPreflight
    });
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Reset configuration
   */
  reset() {
    this.config = null;
  }
};

export { ConfigManager, DEFAULT_CONFIG };
//# sourceMappingURL=chunk-KY4IAQMX.mjs.map
//# sourceMappingURL=chunk-KY4IAQMX.mjs.map