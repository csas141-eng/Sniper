import { PublicKey, Commitment, Finality, Connection } from '@solana/web3.js';
import { Provider } from '@coral-xyz/anchor';

/**
 * Retry configuration
 */
interface RetryConfig {
    maxRetries: number;
    baseDelay: number;
    maxDelay: number;
    backoffMultiplier: number;
}
/**
 * Timeout configuration
 */
interface TimeoutConfig {
    connection: number;
    transaction: number;
    confirmation: number;
}
/**
 * Logging configuration
 */
interface LoggingConfig {
    level: 'silent' | 'error' | 'warn' | 'info' | 'debug' | 'trace';
    enabled: boolean;
    prettyPrint: boolean;
    context?: Record<string, unknown>;
}
/**
 * SDK Configuration interface - simplified to only include non-connection settings
 */
interface LetsBonkConfig {
    programId?: PublicKey;
    commitment?: Commitment;
    finality?: Finality;
    retries?: Partial<RetryConfig>;
    timeouts?: Partial<TimeoutConfig>;
    logging?: Partial<LoggingConfig>;
    skipPreflight?: boolean;
    maxConcurrentRequests?: number;
}
/**
 * Default configuration values
 */
declare const DEFAULT_CONFIG: Required<LetsBonkConfig>;
/**
 * Resolved configuration after applying defaults and validation
 */
interface ResolvedConfig extends Required<LetsBonkConfig> {
    provider: Provider;
    connection: Connection;
}
/**
 * Configuration manager class
 */
declare class ConfigManager {
    private static instance;
    private config;
    private constructor();
    /**
     * Get singleton instance
     */
    static getInstance(): ConfigManager;
    /**
     * Create configuration from connection and optional config
     */
    static create(connection: Connection, userConfig?: LetsBonkConfig): ResolvedConfig;
    /**
     * Internal method to create and validate configuration
     */
    private createConfig;
    /**
     * Validate user configuration
     */
    private validateConfig;
    /**
     * Merge user configuration with defaults
     */
    private mergeWithDefaults;
    /**
     * Create provider with dummy wallet for Anchor program initialization
     */
    private createProvider;
    /**
     * Get current configuration
     */
    getConfig(): ResolvedConfig | null;
    /**
     * Reset configuration
     */
    reset(): void;
}

/**
 * Base SDK Error class with structured error information
 */
declare abstract class SDKError extends Error {
    readonly cause?: Error | undefined;
    readonly context?: Record<string, unknown> | undefined;
    abstract readonly code: string;
    abstract readonly category: ErrorCategory;
    constructor(message: string, cause?: Error | undefined, context?: Record<string, unknown> | undefined);
    /**
     * Convert error to JSON for logging/serialization
     */
    toJSON(): ErrorJSON;
}
/**
 * Configuration related errors
 */
declare class ConfigurationError extends SDKError {
    readonly code = "CONFIGURATION_ERROR";
    readonly category = ErrorCategory.Configuration;
}
/**
 * Validation related errors
 */
declare class ValidationError extends SDKError {
    readonly field?: string | undefined;
    readonly value?: unknown | undefined;
    readonly code = "VALIDATION_ERROR";
    readonly category = ErrorCategory.Validation;
    constructor(message: string, field?: string | undefined, value?: unknown | undefined, cause?: Error);
}
/**
 * Network/RPC related errors
 */
declare class NetworkError extends SDKError {
    readonly endpoint?: string | undefined;
    readonly statusCode?: number | undefined;
    readonly code = "NETWORK_ERROR";
    readonly category = ErrorCategory.Network;
    constructor(message: string, endpoint?: string | undefined, statusCode?: number | undefined, cause?: Error);
}
/**
 * Transaction related errors
 */
declare class TransactionError extends SDKError {
    readonly signature?: string | undefined;
    readonly instructionIndex?: number | undefined;
    readonly code = "TRANSACTION_ERROR";
    readonly category = ErrorCategory.Transaction;
    constructor(message: string, signature?: string | undefined, instructionIndex?: number | undefined, cause?: Error);
}
/**
 * Account related errors (PDAs, token accounts, etc.)
 */
declare class AccountError extends SDKError {
    readonly address?: string | undefined;
    readonly accountType?: string | undefined;
    readonly code = "ACCOUNT_ERROR";
    readonly category = ErrorCategory.Account;
    constructor(message: string, address?: string | undefined, accountType?: string | undefined, cause?: Error);
}
/**
 * Program/Smart contract related errors
 */
declare class ProgramError extends SDKError {
    readonly programId?: string | undefined;
    readonly instructionName?: string | undefined;
    readonly errorCode?: number | undefined;
    readonly code = "PROGRAM_ERROR";
    readonly category = ErrorCategory.Program;
    constructor(message: string, programId?: string | undefined, instructionName?: string | undefined, errorCode?: number | undefined, cause?: Error);
}
/**
 * Timeout related errors
 */
declare class TimeoutError extends SDKError {
    readonly timeoutMs?: number | undefined;
    readonly operation?: string | undefined;
    readonly code = "TIMEOUT_ERROR";
    readonly category = ErrorCategory.Timeout;
    constructor(message: string, timeoutMs?: number | undefined, operation?: string | undefined, cause?: Error);
}
/**
 * Error categories for better error handling
 */
declare enum ErrorCategory {
    Configuration = "configuration",
    Validation = "validation",
    Network = "network",
    Transaction = "transaction",
    Account = "account",
    Program = "program",
    Timeout = "timeout",
    Unknown = "unknown"
}
/**
 * Error JSON representation
 */
interface ErrorJSON {
    name: string;
    message: string;
    code: string;
    category: ErrorCategory;
    context?: Record<string, unknown>;
    stack?: string;
    cause?: {
        name: string;
        message: string;
        stack?: string;
    };
}
/**
 * Result type for operations that can fail
 */
type Result<T, E extends SDKError = SDKError> = {
    success: true;
    data: T;
    error?: never;
} | {
    success: false;
    data?: never;
    error: E;
};
/**
 * Success result constructor
 */
declare function success<T>(data: T): Result<T, never>;
/**
 * Error result constructor
 */
declare function failure<E extends SDKError>(error: E): Result<never, E>;
/**
 * Utility function to create a Result from a Promise
 */
declare function tryAsync<T, E extends SDKError = SDKError>(promise: Promise<T>, errorMapper?: (error: Error) => E): Promise<Result<T, E>>;
/**
 * Utility function to create a Result from a synchronous operation
 */
declare function trySync<T, E extends SDKError = SDKError>(fn: () => T, errorMapper?: (error: Error) => E): Result<T, E>;
/**
 * Type guards for error handling
 */
declare function isSDKError(error: unknown): error is SDKError;
declare function isConfigurationError(error: unknown): error is ConfigurationError;
declare function isValidationError(error: unknown): error is ValidationError;
declare function isNetworkError(error: unknown): error is NetworkError;
declare function isTransactionError(error: unknown): error is TransactionError;
declare function isAccountError(error: unknown): error is AccountError;
declare function isProgramError(error: unknown): error is ProgramError;
declare function isTimeoutError(error: unknown): error is TimeoutError;

/**
 * Log levels supported by the SDK
 */
type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'debug' | 'trace';
/**
 * Log context for structured logging
 */
interface LogContext {
    operation?: string;
    transactionId?: string;
    signature?: string;
    address?: string;
    mint?: string;
    amount?: string;
    slippage?: number;
    duration?: number;
    error?: unknown;
    [key: string]: unknown;
}
/**
 * Performance measurement interface
 */
interface PerformanceTimer {
    end(context?: LogContext): void;
}
/**
 * SDK Logger class with structured logging and performance monitoring
 */
declare class SDKLogger {
    private logger;
    private config;
    private static instance;
    constructor(config: LoggingConfig);
    /**
     * Get singleton instance (used internally by SDK)
     */
    static getInstance(config?: LoggingConfig): SDKLogger;
    /**
     * Create a new logger instance
     */
    static create(config: LoggingConfig): SDKLogger;
    /**
     * Reset singleton instance
     */
    static reset(): void;
    /**
     * Create pino logger with configuration
     */
    private createLogger;
    /**
     * Create child logger with additional context
     */
    child(context: LogContext): SDKLogger;
    /**
     * Log error message
     */
    error(message: string, context?: LogContext): void;
    /**
     * Log warning message
     */
    warn(message: string, context?: LogContext): void;
    /**
     * Log info message
     */
    info(message: string, context?: LogContext): void;
    /**
     * Log debug message
     */
    debug(message: string, context?: LogContext): void;
    /**
     * Log trace message
     */
    trace(message: string, context?: LogContext): void;
    /**
     * Start performance timer
     */
    startTimer(operation: string, context?: LogContext): PerformanceTimer;
    /**
     * Log transaction lifecycle events
     */
    logTransaction(event: TransactionEvent, context: LogContext): void;
    /**
     * Log API calls
     */
    logApiCall(method: string, endpoint: string, context?: LogContext): PerformanceTimer;
    /**
     * Log account operations
     */
    logAccount(operation: AccountOperation, address: string, context?: LogContext): void;
    /**
     * Log pool operations
     */
    logPool(operation: PoolOperation, poolAddress: string, context?: LogContext): void;
    /**
     * Log trade operations
     */
    logTrade(operation: TradeOperation, context: TradeContext): void;
    /**
     * Log errors with stack trace
     */
    logError(error: Error, context?: LogContext): void;
    /**
     * Log configuration changes
     */
    logConfig(message: string, config: unknown): void;
    /**
     * Get current log level
     */
    getLevel(): LogLevel;
    /**
     * Check if logging is enabled for a level
     */
    isLevelEnabled(level: LogLevel): boolean;
    /**
     * Update logger configuration
     */
    updateConfig(newConfig: Partial<LoggingConfig>): void;
}
/**
 * Transaction lifecycle events
 */
type TransactionEvent = 'building' | 'built' | 'signing' | 'sending' | 'sent' | 'confirming' | 'confirmed' | 'failed';
/**
 * Account operations
 */
type AccountOperation = 'creating' | 'fetching' | 'updating' | 'closing';
/**
 * Pool operations
 */
type PoolOperation = 'initializing' | 'fetching' | 'updating' | 'migrating';
/**
 * Trade operations
 */
type TradeOperation = 'buying' | 'selling' | 'swapping';
/**
 * Trade context for logging
 */
interface TradeContext extends LogContext {
    mint?: string;
    amountIn?: string;
    amountOut?: string;
    slippage?: number;
    fee?: string;
}
/**
 * Create a logger instance (utility function)
 */
declare function createLogger(config: LoggingConfig): SDKLogger;
/**
 * Get the default logger instance
 */
declare function getLogger(): SDKLogger;
/**
 * Log level priorities for external configuration
 */
declare const LOG_LEVEL_PRIORITIES: Record<LogLevel, number>;

export { AccountError, type AccountOperation, ConfigManager, ConfigurationError, DEFAULT_CONFIG, ErrorCategory, type ErrorJSON, LOG_LEVEL_PRIORITIES, type LetsBonkConfig, type LogContext, type LogLevel, type LoggingConfig, NetworkError, type PerformanceTimer, type PoolOperation, ProgramError, type ResolvedConfig, type Result, type RetryConfig, SDKError, SDKLogger, type TimeoutConfig, TimeoutError, type TradeContext, type TradeOperation, TransactionError, type TransactionEvent, ValidationError, createLogger, failure, getLogger, isAccountError, isConfigurationError, isNetworkError, isProgramError, isSDKError, isTimeoutError, isTransactionError, isValidationError, success, tryAsync, trySync };
