'use strict';

var chunkN5COKLPQ_js = require('./chunk-N5COKLPQ.js');
var web3_js = require('@solana/web3.js');
var anchor = require('@coral-xyz/anchor');
var zod = require('zod');

/* LetsBonkSDK - Modern TypeScript Web3 SDK */
var LetsBonkConfigSchema = zod.z.object({
  // Program configuration
  programId: zod.z.instanceof(web3_js.PublicKey).optional(),
  // Connection settings
  commitment: zod.z.enum(["processed", "confirmed", "finalized"]).optional(),
  finality: zod.z.enum(["confirmed", "finalized"]).optional(),
  // Performance configuration
  retries: zod.z.object({
    maxRetries: zod.z.number().min(0).optional(),
    baseDelay: zod.z.number().min(0).optional(),
    maxDelay: zod.z.number().min(0).optional(),
    backoffMultiplier: zod.z.number().min(1).optional()
  }).optional(),
  timeouts: zod.z.object({
    connection: zod.z.number().min(0).optional(),
    transaction: zod.z.number().min(0).optional(),
    confirmation: zod.z.number().min(0).optional()
  }).optional(),
  logging: zod.z.object({
    level: zod.z.enum(["silent", "error", "warn", "info", "debug", "trace"]).optional(),
    enabled: zod.z.boolean().optional(),
    prettyPrint: zod.z.boolean().optional(),
    context: zod.z.record(zod.z.any()).optional()
  }).optional(),
  // Advanced configuration
  skipPreflight: zod.z.boolean().optional(),
  maxConcurrentRequests: zod.z.number().min(1).optional()
});
var DEFAULT_CONFIG = {
  commitment: "confirmed",
  finality: "confirmed",
  programId: new web3_js.PublicKey("11111111111111111111111111111111"),
  // Placeholder
  retries: {
    maxRetries: 3,
    baseDelay: 1e3,
    maxDelay: 1e4,
    backoffMultiplier: 2
  },
  timeouts: {
    connection: 3e4,
    transaction: 6e4,
    confirmation: 12e4
  },
  logging: (() => {
    const isTestEnv = process.env.NODE_ENV === "test" || process.env.JEST_WORKER_ID !== void 0;
    return {
      level: isTestEnv ? "error" : "info",
      enabled: true,
      prettyPrint: !isTestEnv,
      context: {}
    };
  })(),
  skipPreflight: false,
  maxConcurrentRequests: 10
};
var ConfigManager = class _ConfigManager {
  static instance;
  config = null;
  constructor() {
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_ConfigManager.instance) {
      _ConfigManager.instance = new _ConfigManager();
    }
    return _ConfigManager.instance;
  }
  /**
   * Create configuration from connection and optional config
   */
  static create(connection, userConfig = {}) {
    const manager = _ConfigManager.getInstance();
    return manager.createConfig(connection, userConfig);
  }
  /**
   * Internal method to create and validate configuration
   */
  createConfig(connection, userConfig) {
    try {
      const validatedConfig = this.validateConfig(userConfig);
      const mergedConfig = this.mergeWithDefaults(validatedConfig);
      const provider = this.createProvider(connection, mergedConfig);
      const resolvedConfig = {
        ...mergedConfig,
        provider,
        connection
      };
      this.config = resolvedConfig;
      return resolvedConfig;
    } catch (error) {
      if (error instanceof zod.z.ZodError) {
        throw new chunkN5COKLPQ_js.ValidationError(
          `Configuration validation failed: ${error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ")}`,
          "config",
          userConfig,
          error
        );
      }
      throw new chunkN5COKLPQ_js.ConfigurationError(
        "Failed to create configuration",
        error instanceof Error ? error : new Error(String(error)),
        { userConfig }
      );
    }
  }
  /**
   * Validate user configuration
   */
  validateConfig(config) {
    return LetsBonkConfigSchema.parse(config);
  }
  /**
   * Merge user configuration with defaults
   */
  mergeWithDefaults(config) {
    return {
      commitment: config.commitment || DEFAULT_CONFIG.commitment,
      finality: config.finality || DEFAULT_CONFIG.finality,
      programId: config.programId || DEFAULT_CONFIG.programId,
      retries: { ...DEFAULT_CONFIG.retries, ...config.retries },
      timeouts: { ...DEFAULT_CONFIG.timeouts, ...config.timeouts },
      logging: { ...DEFAULT_CONFIG.logging, ...config.logging },
      skipPreflight: config.skipPreflight ?? DEFAULT_CONFIG.skipPreflight,
      maxConcurrentRequests: config.maxConcurrentRequests || DEFAULT_CONFIG.maxConcurrentRequests
    };
  }
  /**
   * Create provider with dummy wallet for Anchor program initialization
   */
  createProvider(connection, config) {
    const dummyWallet = {
      publicKey: new web3_js.PublicKey("11111111111111111111111111111111"),
      signTransaction: () => Promise.reject(new Error("Read-only wallet")),
      signAllTransactions: () => Promise.reject(new Error("Read-only wallet")),
      payer: new web3_js.PublicKey("11111111111111111111111111111111")
    };
    return new anchor.AnchorProvider(connection, dummyWallet, {
      commitment: config.commitment,
      skipPreflight: config.skipPreflight
    });
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Reset configuration
   */
  reset() {
    this.config = null;
  }
};

exports.ConfigManager = ConfigManager;
exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
//# sourceMappingURL=chunk-FR6ZXLCL.js.map
//# sourceMappingURL=chunk-FR6ZXLCL.js.map